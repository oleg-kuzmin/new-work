# [`.toEqual(value)`](../../index.md)

https://jestjs.io/docs/expect#toequalvalue

Используйте `.toEqual` для рекурсивного сравнения всех свойств экземпляров объектов (также известного как "глубокое" равенство). Он вызывает `Object.is` для сравнения примитивных значений, что даже лучше для тестирования, чем оператор строгого равенства `===`.

Например, `.toEqual` и `.toBe` ведут себя по-разному в этом наборе тестов, поэтому все тесты проходят успешно:

```js
const can1 = {
  flavor: 'grapefruit',
  ounces: 12,
};
const can2 = {
  flavor: 'grapefruit',
  ounces: 12,
};

describe('the La Croix cans on my desk', () => {
  test('have all the same properties', () => {
    expect(can1).toEqual(can2);
  });
  test('are not the exact same can', () => {
    expect(can1).not.toBe(can2);
  });
});
```

> **Совет:** `.toEqual` игнорирует ключи объектов с свойствами `undefined`, элементы массива `undefined`, разреженные массивы или объекты неправильного типа. Чтобы учесть это, используйте `.toStrictEqual` вместо этого.

> **Примечание:** `.toEqual` не будет выполнять глубокую проверку на равенство для двух ошибок. Для проверки на равенство учитывается только свойство `message` об ошибке. Рекомендуется использовать средство сопоставления `.toThrow` для проверки на наличие ошибок.

Если различия между свойствами не помогают вам понять, почему тест завершается неудачно, особенно если отчет большой, вы можете перенести сравнение в функцию `expect`. Например, используйте метод `equals` класса `Buffer`, чтобы определить, содержат ли буферы одинаковое содержимое:

- перепишите `expect(received).toEqual(expected)` на `expect(received.equals(expected)).toBe(true)`
- перепишите `expect(received).not.toEqual(expected)` на `expect(received.equals(expected)).toBe(false)`
