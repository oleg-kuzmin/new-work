# [`.toBe(value)`](../../index.md)

- [Документация](https://jestjs.io/docs/expect#tobevalue)

Используйте `.toBe` для сравнения примитивных значений или для проверки ссылочной идентичности экземпляров объектов. Он вызывает `Object.is` для сравнения значений, что даже лучше для тестирования, чем оператор строгого равенства `===`.

Например, этот код проверит некоторые свойства объекта `can`:

```js
const can = {
  name: 'pamplemousse',
  ounces: 12,
};

describe('the can', () => {
  test('has 12 ounces', () => {
    expect(can.ounces).toBe(12);
  });

  test('has a sophisticated name', () => {
    expect(can.name).toBe('pamplemousse');
  });
});
```

Не используйте `.toBe` c числами с плавающей запятой. Например, из-за округления в JavaScript `0.2 + 0.1` не всегда равно `0.3.` Если у вас есть числа с плавающей запятой, попробуйте вместо этого `.toBeCloseTo`.

Хотя средство сопоставления `.toBe` **проверяет** ссылочную идентичность, оно **сообщает** о тщательном сравнении значений, если утверждение не выполняется. Если различия между свойствами не помогают вам понять, почему тест не выполняется, особенно если отчет большой, вы можете перенести сравнение в функцию `expect`. Например, чтобы определить, являются ли элементы одним и тем же экземпляром или нет:

- перепишите `expect(received).toBe(expected)` на `expect(Object.is(received, expected)).toBe(true)`
- перепишите `expect(received).not.toBe(expected)` на `expect(Object.is(received, expected)).toBe(false)`
