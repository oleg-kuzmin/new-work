# [`useRef()`](../index.md)

Сохраняем значение или ссылку на node не трогая жизненный цикл компонента.

Можно использовать в качестве ссылки на элемент, но может и просто хранить что-то внутри себя в объекте в ключе `current`.

Представляет собой по сути некий объект, у которого есть единственное свойство `current`. Из `current` мы всегда можем получить ссылку на узел. Изначально при создании `createRef` значение переменной `null`, далее устанавливаем атрибут `ref` для элемента jsx. И после монтирования элемента jsx с атрибутом `ref`, мы получим ссылку на этот элемент jsx. `ref` не приводит к обновлению компонента в отличие от `state`.

Значение `useRef` не нужно для рендеринга, оно одинаково между всеми ререндерами.

Вы можете изменить свойство `ref.current`. В отличие от состояния, оно является изменяемым. Однако, если оно содержит объект, который используется для рендеринга (например, часть вашего состояния), то не стоит мутировать этот объект.

Когда вы изменяете свойство `ref.current`, React не перерисовывает ваш компонент. React не знает, когда вы изменяете его, потому что `ref` - это обычный объект JavaScript.

Не записывайте или читайте `ref.current` во время рендеринга, кроме инициализации. Иначе это сделает поведение вашего компонента непредсказуемым.

`useRef` подходит для хранения информации, которая не влияет на визуальный вывод вашего компонента. Например, если вам нужно хранить ID `setInterval` и получить его позже, вы можете поместить его в `useRef`. Чтобы обновить значение внутри `useRef`, вам нужно вручную изменить свойство `current`.

`useRef()` часто используется для фокуса на элементе.

## Синтаксис

```jsx
// изначальный объект
const inputElementRef = useRef(null);
```

## Пример

```jsx
// импорт
import { useRef } from 'react';

function App() {
  // создание
  const inputElement = useRef(null);

  // Добавление атрибута
  return (
    <div>
      <input type="text" ref={inputElement} />
    </div>
  );
}
```
