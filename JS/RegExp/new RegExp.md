# `new RegExp()`

_(regular expression: регулярное выражение)_

Создать регулярное выражение можно двумя способами. В обоих случаях созданное регулярное выражение будет являтся экземпляром встроенного класса `RegExp`.

Основная разница между этими двумя способами создания заключается в том, что слеши `/.../` не допускают возможность использовать шаблонные строки.

Слеши `/.../` используются, когда мы на момент написания кода точно знаем, каким будет регулярное выражение. А `new RegExp` – когда мы хотим создать регулярное выражение с использованием шаблонной строки.

## Синтаксис

_1 способ - короткий синтаксис_

```js
const regexp = /шаблон/флаги;
```

_2 способ - используем RegExp_

```js
regexp = new RegExp('шаблон', '[флаги]');
```

### `шаблон`

Шаблоны — набор символов, которые используют для поиска определённых сочетаний символов в тексте.

#### `Символы`

- `a` Конкретный символ a (например `a`)
- `a.` Конкретный символ и еще один любой символ (например `ab`)
- `a..` Конкретный символ и еще два любых символа (например `abc`)

#### `Метасимволы`

- `.` Вообще любой символ
- `\w` Буквенный или цифровой символ или знак подчёркивания (эквивалент `[[:word:]]`)
- `\W` Любой символ, кроме буквенного или цифрового символа или знака подчёркивания (эквивалент `[^[:word:]]`)
- `\d` Цифровой символ (эквивалент `[0-9]`)
- `\D` Нецифровой символ (эквивалент `[^0-9]`)
- `\s` Пробельный символ (эквивалент `[ \f\n\r\t\v]`)
- `\S` Непробельный символ (эквивалент `[^ \f\n\r\t\v]`)
- `\b` Граница слова
- `\B` Неграница слова

#### `Метасимволы начало и конец`

- `^abc` Строка должна начинаться с символов a, b, c (например `abc111`)
- `abc$` Строка должна заканчиваться на символы a, b, c (например `111abc`)
- `^abc$` Строка должна состоять из символов a, b, c (например `abc`)
- `\babc` Слово должно начинаться с символов a, b, c (например `abc111`)
- `abc\b` Слово должно заканчиваться на символы a, b, c (например `111abc`)
- `\babc\b` Слово должно состоять из символов a, b, c (например `abc`)

#### `Пробельные символы`

- ` ` Пробел
- `\r` Возврат каретки (Carriage return, CR)
- `\n` Перевод строки (Line feed, LF)
- `\t` Табуляция (Tab)
- `\v` Вертикальная табуляция (vertical tab)
- `\f` Конец страницы (Form feed)
- `[\b]` Возврат на 1 символ (Backspace)

#### `Классы символов`

- `[[:alnum:]]` Буквы или цифры: `[а-яА-ЯёЁa-zA-Z0-9]`
- `[[:alpha:]]` Только буквы: `[а-яА-ЯёЁa-zA-Z]`
- `[[:digit:]]` Только цифры: `[0-9]`
- `[[:graph:]]` Только отображаемые символы (пробелы, служебные знаки и т. д. не учитываются)
- `[[:print:]]` Отображаемые символы и пробелы
- `[[:space:]]` Пробельные символы `[ \f\n\r\t\v]`
- `[[:punct:]]` Знаки пунктуации: `!"#$%&'()*+,\-./:;<=>?@[]^_{|}` + апостроф &#96;
- `[[:word:]]` Буквенный или цифровой символ или знак подчёркивания: `[а-яА-ЯёЁa-zA-Z0-9_]`

#### `Экранирование`

Для экранирования символа используется `\`.

Однозначно нужно экранировать спец. символы (`[]\/^$.|?*+(){}`), если вы хотите найти их в тексте.

#### `Скобки`

Единственный допустимый разделитель — это дефис. Если система видит дефис внутри квадратных скобок — значит, это диапазон.

- `[aA]` Один символ a или один символ A (например `a`, `A`)
- `[a-z]` Диапазон любой одиночный символ от a до z (например `b`)
- `[^a]` ^ внутри [] означает исключение, один символ не a (например `b`)

#### `Группы символов`

Круглые скобки обозначают группу символов. Зачем нужны скобки? Показать, где начинается и заканчивается группа.

Но для замены одной буквы лучше использовать `[]`, так как сравнение с символьным классом выполняется проще, чем обработка группы с проверкой на все её возможные модификаторы.

Каждую часть регулярного выражения мы берем в скобки чтобы показать системе, где заканчивается выбор.

Каждой группе присваивается номер, по которому к ней можно обратиться. Нумерация у групп начинается с 1.

- `А(н|л)я` соответствует набору символов `Аня`, `Аля`

#### `Ссылка назад`

##### Регулярное выражение `[ ]+(\w+)[ ]+\1`

`[ ]+` - один или несколько пробелов, так мы ограничиваем слово. В принципе, тут можно заменить на метасимвол \b.

`(\w+)` - любой буквенный или цифровой символ, или знак подчеркивания. Квантификатор «+» означает, что символ должен идти минимум один раз. А то, что мы взяли все это выражение в круглые скобки, говорит о том, что это группа. Зачем она нужна, мы пока не знаем, ведь рядом с ней нет квантификатора. Значит, не для повторения. Но в любом случае, найденный символ или слово — это группа 1.

`[ ]+` - снова один или несколько пробелов.

`\1` - повторение группы 1. Это и есть ссылка назад. Так она записывается в JavaScript-е.

#### `Просмотр вперед и назад`

Находит какое-то место в тексте, но не включает найденное слово в выборку.

##### `(?=шаблон)` Позитивный просмотр вперёд (`Блюдо(?=11)`)

- Блюдо1
- `Блюдо`11 - нашел Блюдо11
- `Блюдо`113 - нашел Блюдо11
- Блюдо511

##### `(?!шаблон)` Негативный просмотр вперёд (с отрицанием) (`Блюдо(?!11)`)

- `Блюдо`1 - нашел не Блюдо11
- Блюдо11
- Блюдо113
- `Блюдо`511 - нашел не Блюдо11

##### `(?<=шаблон)` Позитивный просмотр назад (`(?<=Ольга )Назина`)

- Ольга `Назина` - нашел Назину, у которой до стоит Ольга
- Анна Назина

##### `(?шаблон)` Негативный просмотр назад (с отрицанием) (`(?<!Ольга )Назина`)

- Ольга Назина
- Анна `Назина` - нашел Назину, которая не Ольга

#### `Логические значения`

Eсли мы хотим указать допустимые значения:

- Одного символа — используем `[]`
- Нескольких символов или целого слова — используем `|`

#### `Квантификаторы`

Позволяют указать количество повторений.

Квантификатор применяется к последнему символу или группе символов, если они взяты в круглые скобки.

Обычным (жадным) квантификаторам соответствует максимально длинная строка из возможных.

Ленивым квантификаторам соответствует минимальная строка из возможных. Для определения ленивого квантификатора нужно добавить после него знак вопроса `?`.

Ревнивым квантификаторам также соответствует максимально длинная строка из возможных, но при этом учитываются уже занятые символы (найденные символы не могут использовать повторно для составления поиска второй строки). Для определения ревнивого квантификатора нужно добавить после него знак плюса `+`.

Если мы понимаем, что нашли не то, что хотели, можно определить квантификатор как ленивый добавив после него знак вопроса.

- `+` Одно или более повторений (например `\w+@` означает одно или более повторений `\w` до @)
- `?` Ноль или одно повторение
- `*` Ноль или более повторений
- `a{n}` Ровно n повторений (например `a{3}` для `aaa`)
- `a{n,m}` От n до m повторений включительно (например `a{2,3}` для `aa`, `aaa`)
- `{n,}` Не менее n повторений (например `a{3,}` для `aaa`, `aaaa`)
- `{,m}` Не более m повторений (например `a{,3}` для `aaa`)

#### `Ленивые квантификаторы`

- `*?` Ноль или более повторений (найдет вообще пустую строку)
- `+?` Одно или более повторений (найдет строку с одним повторением)
- `{n,}?` Не менее n повторений (найдет строку с n повторений)

#### `Ревнивые квантификаторы`

- `*+` Ноль или более повторений (например `ab(xa)*+a` в `abxaabxaa` найдет только одну строку)
- `?+` Ноль или одно повторение
- `++` Одно или более повторений
- `{n,}+` Не менее n повторений

### `флаги` (опционально)

Cпециальные флаги, которые можно добавить к регулярному выражению для изменения его поведения.

- `g` - Глобальный поиск, ищет в строке не одно, а все совпадения
- `i` - Игнорирование регистра, игнорирует различия между верхним и нижним регистром
- `m` - Многострочный поиск, позволяет искать совпадения в нескольких строках

## Пример

```js
// регулярное выражение, которое ищет все цифры в строке
const regexp = new RegExp('\\d', 'g');

// регулярное выражение, которое ищет все цифры в строке
const regexp = /\d/g;

// без флагов
const regexp = /\d/;

// Все русские буквы
const regexp = /[А-Яа-яЁё]/;

// все английские буквы
const regexp = /[a-zA-Z]/;

// Набор из букв (латиница + кириллица), а также пробелов и дефисов
const regexp = /^([а-яА-ЯёЁa-zA-Z]|\s|-)+$/;

// Номер кредитки:
const regexp = /[0-9]{13,16}/;

// ICQ:
const regexp = /([1-9])+(?:-?\d){4,}/;

// Набор из букв и цифр (латиница):
const regexp = /^[a-zA-Z0-9]+$/;

// Набор из букв и цифр (латиница + кириллица):
const regexp = /^[а-яА-ЯёЁa-zA-Z0-9]+$/;

// Домен (например abcd.com):
const regexp = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}$/;

// IPv4: (подкорректировано runcore)
const regexp = /((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)/;

// IPv6:
const regexp = /((^|:)([0-9a-fA-F]{0,4})){1,8}$/;

// Имя пользователя (с ограничением 2-20 символов, которыми могут быть буквы и цифры, первый символ обязательно буква):
const regexp = /^[a-zA-Z][a-zA-Z0-9-_\.]{1,20}$/;

// Пароль (Строчные и прописные латинские буквы, цифры):
const regexp = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\s).*$/;

// Пароль (Строчные и прописные латинские буквы, цифры, спецсимволы. Минимум 8 символов):
const regexp = /(?=^.{8,}$)((?=.*\d)|(?=.*\W+))(?![.\n])(?=.*[A-Z])(?=.*[a-z]).*$/;

// Дата в формате YYYY-MM-DD:
const regexp = /[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|1[0-9]|2[0-9]|3[01])/;

// UPD. Более строгая проверка, предложенная runcore:
const regexp = /(19|20)\d\d-((0[1-9]|1[012])-(0[1-9]|[12]\d)|(0[13-9]|1[012])-30|(0[13578]|1[02])-31)/;

// Дата в формате DD/MM/YYYY:
const regexp = /(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)\d\d/;

// Целые числа и числа с плавающей точкой (разделитель точка):
const regexp = /^\-?\d+(\.\d{0,})?/;

// UUID:
const regexp = /^[0-9A-Fa-f]{8}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{12}$/;

// Широта или долгота:
const regexp = /-?\d{1,3}\.\d+/;

// Почта E-mail (от kvf77):
const regexp = /^[-\w.]+@([A-z0-9][-A-z0-9]+\.)+[A-z]{2,4}$/;

// UPD. Время в формате HH:MM:SS (от runcore):
const regexp = /^([0-1]\d|2[0-3])(:[0-5]\d){2}$/;

// UPD. Mac-адрес (от tiahin):
const regexp = /([0-9a-fA-F]{2}([:-]|$)){6}$|([0-9a-fA-F]{4}([.]|$)){3}/;
```
