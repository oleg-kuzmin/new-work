# `async await`

Асинхронная функция помечается специальным ключевым словом `async`.

Плюсы `async`:

- Код чище и короче. У нас больше нет цепочек из `then()`, вместо этого мы получаем плоскую структуру, которая по виду похожа на синхронный код. Условия и вложенные конструкции становятся чище и проще читаются.
- Мы можем обрабатывать ошибки с `try-catch`. Как и с синхронным кодом, обработка ошибок сводится к оборачиванию опасных операций в `try-catch`.
- В отличие от `.catch()` промисов, `try-catch` поймает не только ошибки, которые были внутри асинхронных функций, но также и ошибки, которые возникли во время обычных синхронных операций.
- Можно ставить брейкпоинты (точки останова). Для отладки мы можем поставить брейкпоинт куда угодно, он сработает.

## Синтаксис

```js
// Обычная функция
async function request() {
  // без try-catch
  const response = await fetch('/api/posts/');
  const data = await response.json();
  return data;

  // с try-catch
  try {
    const response = await fetch('/api/posts/');
    const data = await response.json();
    return data;
  } catch (error) {
    console.log(error);
  }
}

// Функциональное выражение
const request = async () => {};

// Метод класса
class SomeClass {
  async request() {}
}

// Так как возвращается promise, можем обработать результат обычным образом
request().then(() => {});
```

### `async`

У слова `async` один простой смысл: эта функция всегда возвращает объект `promise`. Значения других типов оборачиваются в завершившийся успешно `promise` автоматически.

### `await`

Внутри асинхронных функций можно вызывать другие асинхронные функции, без каких-либо then() или колбэков, с помощью ключевого слова await.

Ключевое слово `await` заставит интерпретатор JavaScript ждать до тех пор, пока `promise` справа от `await` не выполнится (`fulfilled`). После чего `await` вернёт результат `promise`, и выполнение кода продолжится дальше.

## Возвращает

### `object promise`

`.state` - `fulfilled`
`.result` - `value`
