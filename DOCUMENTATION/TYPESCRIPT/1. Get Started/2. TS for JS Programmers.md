# [TypeScript для программистов JavaScript](../index.md)

- [Типы по логическому выводу](#типы-по-логическому-выводу)
- [Определение типов](#определение-типов)
- [Композиция типов](#композиция-типов)
  - [Unions](#unions)
  - [Generics](#generics)
- [Система структурного типа](#система-структурного-типа)
- [Следующие шаги](#следующие-шаги)

TypeScript находится в необычных отношениях с JavaScript. TypeScript предлагает все возможности JavaScript и дополнительный уровень поверх них: систему типов TypeScript.

Например, JavaScript предоставляет такие языковые примитивы, как `string` и `number`, но не проверяет, правильно ли вы их назначили. Это делает TypeScript.

Это означает, что ваш существующий рабочий код на JavaScript также является кодом на TypeScript. Основное преимущество TypeScript заключается в том, что он может выявить неожиданное поведение в вашем коде, снижая вероятность возникновения ошибок.

В этом руководстве представлен краткий обзор TypeScript с акцентом на его систему ввода.

## [Типы по логическому выводу](#)

TypeScript знает язык JavaScript и во многих случаях будет генерировать типы для вас. Например, при создании переменной и присвоении ей определенного значения TypeScript будет использовать значение в качестве ее типа.

```ts
let helloWorld = 'Hello World'; // let helloWorld: string
```

Понимая, как работает JavaScript, TypeScript может создать систему типов, которая принимает код JavaScript, но содержит типы. Это позволяет использовать систему типов без необходимости добавлять дополнительные символы, чтобы сделать типы явными в вашем коде. Вот как TypeScript узнает, что `HelloWorld` - это `string` в приведенном выше примере.

Возможно, вы написали JavaScript в Visual Studio Code и у вас есть функция автодополнения в редакторе. Visual Studio Code использует TypeScript для упрощения работы с JavaScript.

## [Определение типов](#)

В JavaScript можно использовать широкий спектр шаблонов проектирования. Однако некоторые шаблоны проектирования затрудняют автоматическое определение типов (например, шаблоны, использующие динамическое программирование). Чтобы охватить эти случаи, TypeScript поддерживает расширение языка JavaScript, в котором вы можете указать TypeScript, какими должны быть типы.

Например, чтобы создать объект с предполагаемым типом, который включает в себя `name: string` и `id: number`, вы можете написать:

```ts
const user = {
  name: 'Hayes',
  id: 0,
};
```

Вы можете явно описать форму этого объекта, используя объявление `interface`:

```ts
interface User {
  name: string;
  id: number;
}
```

Затем вы можете объявить, что объект JavaScript соответствует форме вашего нового `interface`, используя синтаксис типа `: TypeName` после объявления переменной:

```ts
const user: User = {
  name: 'Hayes',
  id: 0,
};
```

Если вы предоставите объект, который не соответствует предоставленному вами интерфейсу, TypeScript предупредит вас об этом:

```ts
interface User {
  name: string;
  id: number;
}

const user: User = {
  username: 'Hayes', // Объектный литерал может использовать только известные свойства. "username" не существует в типе "User".
  id: 0,
};
```

Поскольку JavaScript поддерживает классы и объектно-ориентированное программирование, то же самое делает и TypeScript. Вы можете использовать объявление интерфейса с классами:

```ts
interface User {
  name: string;
  id: number;
}

class UserAccount {
  name: string;
  id: number;

  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
  }
}

const user: User = new UserAccount('Murphy', 1);
```

Вы можете использовать интерфейсы для аннотации параметров и возвращаемых значений функций:

```ts
function deleteUser(user: User) {
  // ...
}

function getAdminUser(): User {
  //...
}
```

В JavaScript уже существует небольшой набор примитивных типов, доступных в JavaScript: `boolean`, `bigint`, `null`, `number`, `string`, `symbol` и `undefined`, которые вы можете использовать в интерфейсе. TypeScript расширяет этот список еще несколькими, такими как `any` (разрешить все, что угодно), [`unknown`](https://www.typescriptlang.org/play#example/unknown-and-never) (убедитесь, что кто-то, использующий этот тип, объявляет, что это за тип), [`never`](https://www.typescriptlang.org/play#example/unknown-and-never) (невозможно, чтобы этот тип мог появиться) и `void` (функция, которая возвращает `undefined` или не имеет возвращаемого значения).

Вы увидите, что существует два синтаксиса для построения типов: [`Interfaces` и `Types`](https://www.typescriptlang.org/play/?e=83#example/types-vs-interfaces). Вам следует предпочесть `interface`. Используйте `type`, когда вам нужны конкретные функции.

## [Композиция типов](#)

С помощью TypeScript вы можете создавать сложные типы, комбинируя простые. Для этого есть два популярных способа: `unions` и `generics`.

### [Unions](#)

С помощью `union` вы можете объявить, что тип может быть одним из многих типов. Например, вы можете описать тип `boolean` как имеющий значение `true` или `false`:

```ts
type MyBool = true | false;
```

Примечание: Если вы наведете указатель мыши на `MyBool` в редакторе, вы увидите, что он классифицируется как `boolean`. Это свойство системы структурных типов. Подробнее об этом ниже.

Популярным вариантом использования типов `union` является описание набора литералов `string` или `number`, которыми может быть значение:

```ts
type WindowStates = 'open' | 'closed' | 'minimized';
type LockStates = 'locked' | 'unlocked';
type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
```

`unions` также позволяют обрабатывать различные типы данных. Например, у вас может быть функция, которая принимает `array` или `string`:

```ts
function getLength(obj: string | string[]) {
  return obj.length;
}
```

Чтобы узнать тип переменной, используйте `typeof`:

| Type      | Predicate                          |
| :-------- | :--------------------------------- |
| string    | `typeof s === "string"`            |
| number    | `typeof n === "number"`            |
| boolean   | `typeof b === "boolean"`           |
| undefined | `typeof undefined === "undefined"` |
| function  | `typeof s === "string"`            |
| array     | `typeof f === "function"`          |

Например, вы можете заставить функцию возвращать разные значения в зависимости от того, передается ли ей строка или массив:

```ts
function wrapInArray(obj: string | string[]) {
  if (typeof obj === 'string') {
    return [obj]; // (parameter) obj: string
  }
  return obj;
}
```

### [Generics](#)

`Generics` предоставляют переменные для типов. Распространенным примером является массив. Массив без `generics` может содержать все, что угодно. Массив с `generics` может описывать значения, которые содержит массив.

```ts
type StringArray = Array<string>;
type NumberArray = Array<number>;
type ObjectWithNameArray = Array<{ name: string }>;
```

Вы можете объявить свои собственные типы, использующие `generics`:

```ts
interface Backpack<Type> {
  add: (obj: Type) => void;
  get: () => Type;
}

// Эта строка является сокращением, позволяющим сообщить TypeScript о существовании
// константы под названием `backpack` и не беспокоиться о том, откуда она взялась.
declare const backpack: Backpack<string>;

// object - это строка, потому что мы объявили ее выше как переменную часть Backpack.
const object = backpack.get();

// Поскольку переменная backpack представляет собой строку, вы не можете передать число в функцию add.
backpack.add(23); // Аргумент типа "number" нельзя назначить параметру типа "string".
```

## [Система структурного типа](#)

Один из основных принципов TypeScript заключается в том, что проверка типов фокусируется на форме, которую имеют значения. Иногда это называется “утиная типизация” или “структурная типизация”.

В системе структурных типов, если два объекта имеют одинаковую форму, они считаются относящимися к одному типу.

```ts
interface Point {
  x: number;
  y: number;
}

function logPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}

const point = { x: 12, y: 26 };
logPoint(point); // logs "12, 26"
```

Переменная `point` никогда не объявляется как тип `Point`. Однако TypeScript сравнивает форму `point` с формой `Point` при проверке типа. Они имеют одинаковую форму, поэтому код проходит.

Для сопоставления формы требуется только подмножество полей объекта.

```ts
const point3 = { x: 12, y: 26, z: 89 };
logPoint(point3); // logs "12, 26"

const rect = { x: 33, y: 3, width: 30, height: 80 };
logPoint(rect); // logs "33, 3"

const color = { hex: '#187ABF' };
logPoint(color);

// Аргумент типа '{ hex: string; }' не присваивается параметру типа 'Point'.
// В типе '{ hex: string; }' отсутствует следующие свойства из типа - 'Point': x, y
```

Нет никакой разницы между тем, как классы и объекты соответствуют формам:

```ts
class VirtualPoint {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

const newVPoint = new VirtualPoint(13, 56);
logPoint(newVPoint); // logs "13, 56"
```

Если объект или класс обладает всеми требуемыми свойствами, TypeScript сообщит, что они совпадают, независимо от деталей реализации.

## [Следующие шаги](#)

Это был краткий обзор синтаксиса и инструментов, используемых в повседневном TypeScript. Отсюда вы можете:

- Прочитать [Справочник от начала до конца](<../2. Handbook/1. The TypeScript Handbook.md>)
- Изучить примеры в [песочницах](https://www.typescriptlang.org/play#show-examples)
- Продолжение - [TS инструменты за 5 минут](<./3. TS Tooling in 5 minutes.md>)
