# [Состояние как моментальный снимок](../../index.md)

- [Обзор](#обзор)
- [Установка состояния запускает триггер рендеринга](#установка-состояния-запускает-триггер-рендеринга)
- [Рендеринг делает моментальный снимок во времени](#рендеринг-делает-моментальный-снимок-во-времени)
- [Состояние с течением времени](#состояние-с-течением-времени)
- [Резюме](#резюме)
- [Следующий шаг](#следующий-шаг)

## [Обзор](#)

**Переменные состояния могут выглядеть как обычные переменные JavaScript, которые вы можете читать и записывать. Однако состояние ведет себя скорее как снимок. Установка состояния не изменяет переменную состояния, которая у вас уже есть, а вместо этого запускает повторный рендеринг.**

### Ты выучишь

- Как установка состояния запускает повторный рендеринг
- Когда и как обновляется состояние
- Почему состояние не обновляется сразу после установки
- Как обработчики событий получают доступ к «снимку» состояния

## [Установка состояния запускает триггер рендеринга](#)

Вы можете думать о своем пользовательском интерфейсе как об изменении непосредственно в ответ на пользовательское событие, например, на клик. В React это работает немного иначе, чем в этой ментальной модели. На предыдущей странице вы видели, что [установка состояния запрашивает повторный рендеринг](https://react.dev/learn/render-and-commit#step-1-trigger-a-render) из React. Это означает, что для того, чтобы интерфейс отреагировал на событие, вам нужно обновить состояние.

В этом примере, когда вы нажимаете «send», `setIsSent(true)` сообщает React о необходимости повторного рендера пользовательского интерфейса:

```jsx
// App.js
import { useState } from 'react';

export default function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Hi!');
  if (isSent) {
    return <h1>Your message is on its way!</h1>;
  }
  return (
    <form
      onSubmit={e => {
        e.preventDefault();
        setIsSent(true);
        sendMessage(message);
      }}>
      <textarea placeholder="Message" value={message} onChange={e => setMessage(e.target.value)} />
      <button type="submit">Send</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}
```

Вот что происходит, когда вы нажимаете кнопку:

1. Выполняется обработчик событий `onSubmit`.
2. `setIsSent(true)` устанавливает для `isSent` значение `true` и ставит в очередь новый рендеринг.
3. React перерисовывает компонент в соответствии с новым значением `isSent`.

Давайте подробнее рассмотрим связь между состоянием и рендерингом.

## [Рендеринг делает моментальный снимок во времени](#)

[«Рендеринг»](https://react.dev/learn/render-and-commit#step-2-react-renders-your-components) означает, что React вызывает ваш компонент, который является функцией. JSX, который вы возвращаете из этой функции, подобен моментальному снимку пользовательского интерфейса во времени. Его props, обработчики событий и локальные переменные были рассчитаны с использованием его состояния во время рендеринга.

В отличие от фотографии или кадра фильма, возвращаемый вами «снимок» пользовательского интерфейса является интерактивным. Он включает логику, например обработчики событий, которые определяют, что происходит в ответ на ввод. React обновляет экран в соответствии с этим снимком и подключает обработчики событий. В результате нажатие кнопки вызовет обработчик щелчков из вашего JSX.

Когда React повторно рендерит компонент:

1. React снова вызывает вашу функцию.
2. Ваша функция возвращает новый снимок JSX.
3. Затем React обновляет экран в соответствии со снимком, который вернула ваша функция.

Как память компонента, состояние не похоже на обычную переменную, которая исчезает после return из вашей функции. Состояние на самом деле «живет» в самом React — как на полке! — вне вашей функции. Когда React вызывает ваш компонент, он дает вам снимок состояния для этого конкретного рендера. Ваш компонент возвращает снимок пользовательского интерфейса со свежим набором всех свойств и обработчиков событий в своем JSX, вычисленные с использованием значений состояния из этого рендера!

Вот небольшой эксперимент, чтобы показать вам, как это работает. В этом примере вы могли бы ожидать, что нажатие кнопки «+3» увеличит счетчик три раза, потому что он вызывает `setNumber(number + 1)` три раза.

Посмотрите, что произойдет, если вы нажмете кнопку «+3»:

```jsx
// App.js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}>
        +3
      </button>
    </>
  );
}
```

Обратите внимание, что число увеличивается только один раз за один клик!

Установка состояния изменяет его только для следующего рендера. Во время первого рендера `number` был `0`. Вот почему в обработчике `onClick` этого рендера значение `number` по-прежнему равно `0` даже после вызова `setNumber(number + 1)`:

```jsx
<button
  onClick={() => {
    setNumber(number + 1);
    setNumber(number + 1);
    setNumber(number + 1);
  }}>
  +3
</button>
```

Вот что обработчик нажатия этой кнопки сообщает React сделать:

- `setNumber(number + 1)`: `number` равно `0`, поэтому `setNumber(0 + 1)`
  - React готовится изменить `number` на `1` при следующем рендеринге.
- `setNumber(number + 1)`: `number` равно `0`, поэтому `setNumber(0 + 1)`
  - React готовится изменить `number` на `1` при следующем рендеринге.
- `setNumber(number + 1)`: `number` равно `0`, поэтому `setNumber(0 + 1)`
  - React готовится изменить `number` на `1` при следующем рендеринге.

Несмотря на то, что вы вызвали `setNumber(number 1)` три раза, в этом обработчике событий рендеринга `number` всегда равен `0`, поэтому вы трижды устанавливаете состояние на `1`. Вот почему после завершения вашего обработчика событий React повторно рендерит компонент с номером, равным `1`, а не `3`.

Вы также можете представить это мысленно заменив переменные состояния их значениями в вашем коде. Поскольку переменная состояния `number` равна `0` для этого рендера, ее обработчик событий выглядит следующим образом:

```jsx
<button
  onClick={() => {
    setNumber(0 + 1);
    setNumber(0 + 1);
    setNumber(0 + 1);
  }}>
  +3
</button>
```

Для следующего рендера `number` равно `1`, поэтому обработчик кликов этого рендера выглядит следующим образом:

```jsx
<button
  onClick={() => {
    setNumber(1 + 1);
    setNumber(1 + 1);
    setNumber(1 + 1);
  }}>
  +3
</button>
```

Вот почему повторное нажатие кнопки установит счетчик на `2`, затем на `3` при следующем нажатии и так далее.

## [Состояние с течением времени](#)

Ну, это было весело. Попробуйте угадать, что вызовет alert при нажатии этой кнопки:

```jsx
// App.js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          alert(number);
        }}>
        +5
      </button>
    </>
  );
}
```

Если вы используете метод подстановки, описанный ранее, вы можете догадаться, что в оповещении отображается «0»:

```jsx
setNumber(0 + 5);
alert(0);
```

Но что, если вы установите таймер на alert, чтобы оно срабатывало только после повторного рендеринга компонента? Будет ли оно показывать «0» или «5»? Угадайте!

```jsx
// App.js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setTimeout(() => {
            alert(number);
          }, 3000);
        }}>
        +5
      </button>
    </>
  );
}
```

Удивлены? Если использовать метод подстановки, то можно увидеть «моментальный снимок» состояния, переданного в alert.

```jsx
setNumber(0 + 5);
setTimeout(() => {
  alert(0);
}, 3000);
```

Состояние, хранящееся в React, могло измениться к моменту срабатывания alert, но оно было запланировано с использованием снимка состояния на момент взаимодействия пользователя с ним!

Значение переменной состояния никогда не меняется в пределах рендера, даже если код ее обработчика событий асинхронный. Внутри `onClick` этого рендера значение `number` продолжает быть `0` даже после вызова `setNumber(number + 5)`. Его значение было «зафиксировано», когда React «сделал снимок» пользовательского интерфейса, вызвав ваш компонент.

Вот пример того, как это делает ваши обработчики событий менее подверженными ошибкам синхронизации. Ниже приведена форма, которая отправляет сообщение с пятисекундной задержкой. Представьте себе такой сценарий:

1. Вы нажимаете кнопку «Send», отправляя «Hello» Алисе.
2. До окончания пятисекундной задержки вы меняете значение поля «To» на «Bob».

Что, по вашему мнению, должно отобразиться в `alert`? Будет ли оно отображать «You said Hello to Alice»? Или будет отображать «You said Hello to Bob»? Сделайте предположение на основе того, что вы знаете, а затем попробуйте:

```jsx
// App.js
import { useState } from 'react';

export default function Form() {
  const [to, setTo] = useState('Alice');
  const [message, setMessage] = useState('Hello');

  function handleSubmit(e) {
    e.preventDefault();
    setTimeout(() => {
      alert(`You said ${message} to ${to}`);
    }, 5000);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        To:{' '}
        <select value={to} onChange={e => setTo(e.target.value)}>
          <option value="Alice">Alice</option>
          <option value="Bob">Bob</option>
        </select>
      </label>
      <textarea placeholder="Message" value={message} onChange={e => setMessage(e.target.value)} />
      <button type="submit">Send</button>
    </form>
  );
}
```

React сохраняет значения состояния «зафиксированными» в пределах обработчиков событий одного рендера. Вам не нужно беспокоиться о том, изменилось ли состояние во время выполнения кода.

Но что, если вы хотите прочитать последнее состояние перед повторным рендерингом? Вам нужно будет использовать [функцию обновления состояния](https://react.dev/learn/queueing-a-series-of-state-updates), описанную на следующей странице!

## [Резюме](#)

- Установка состояния запрашивает новый рендеринг.
- React хранит состояние вне вашего компонента, как на полке.
- Когда вы вызываете `useState`, React предоставляет вам снимок состояния для этого рендера.
- Переменные и обработчики событий не «выживают» после повторных рендеров. Каждый рендер имеет свои собственные обработчики событий.
- Каждый рендер (и функции внутри него) всегда «видят» снимок состояния, который React предоставил этому рендеру.
- Вы можете мысленно подставлять состояние в обработчики событий, подобно тому, как вы думаете о повторном рендере JSX.
- Обработчики событий, созданные в прошлом, имеют значения состояния из рендера, в котором они были созданы.

## [Следующий шаг](#)

- Продолжение - [Глава 5. Постановка в очередь серии обновлений состояния](<./5. Queueing a Series of State Updates.md>)
