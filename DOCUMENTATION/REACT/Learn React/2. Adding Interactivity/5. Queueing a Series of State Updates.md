# [Постановка в очередь серии обновлений состояния](../../index.md)

- [Обзор](#обзор)
- [React обновляет состояние пакетами](#react-обновляет-состояние-пакетами)
- [Обновление одного и того же состояния несколько раз перед следующим рендерингом](#обновление-одного-и-того-же-состояния-несколько-раз-перед-следующим-рендерингом)
  - [Что произойдет, если вы обновите состояние после его замены](#что-произойдет-если-вы-обновите-состояние-после-его-замены)
  - [Что произойдет, если заменить состояние после его обновления](#что-произойдет-если-заменить-состояние-после-его-обновления)
  - [Соглашение об именовании](#соглашение-об-именовании)
- [Резюме](#резюме)
- [Следующий шаг](#следующий-шаг)

## [Обзор](#)

**Установка переменной состояния поставит в очередь другой рендер. Но иногда вам может понадобиться выполнить несколько операций со значением перед постановкой в ​​очередь следующего рендера. Для этого полезно понять, как React пакетирует обновления состояния.**

### Ты выучишь

- Что такое «batching (пакетирование)» и как React использует его для обработки множественных обновлений состояния
- Как применить несколько обновлений к одной и той же переменной состояния подряд

## [React обновляет состояние пакетами](#)

Можно было бы ожидать, что нажатие кнопки «+3» увеличит счетчик в три раза, поскольку он вызывает `setNumber(number + 1)` три раза:

```jsx
// App.js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}>
        +3
      </button>
    </>
  );
}
```

Однако, как вы, возможно, помните из предыдущего раздела, [значения состояний каждого рендера фиксированы](https://react.dev/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time), поэтому значение `number` внутри обработчика событий первого рендера всегда равно `0`, независимо от того, сколько раз вы вызываете `setNumber(1)`:

```jsx
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

Но здесь есть еще один фактор. React ждет, пока весь код в обработчиках событий не будет выполнен, прежде чем обрабатывать обновления вашего состояния. Вот почему повторная визуализация происходит только после всех этих вызовов `setNumber()`.

Это может напомнить вам официанта, принимающего заказ в ресторане. Официант не бежит на кухню при упоминании вашего первого блюда! Вместо этого он позволяет вам закончить свой заказ, позволяет вам вносить в него изменения и даже принимать заказы от других людей за столом.

Это позволяет вам обновлять несколько переменных состояния — даже из нескольких компонентов — не вызывая слишком много повторных рендеров. Но это также означает, что пользовательский интерфейс не будет обновлен до тех пор, пока не завершится ваш обработчик событий и любой код в нем. Такое поведение, также известное как пакетирование, заставляет ваше приложение React работать намного быстрее. Это также позволяет избежать запутанных «полузаконченных» рендеров, где обновлены только некоторые переменные.

React не выполняет пакетирование по нескольким преднамеренным событиям, таким как щелчки — каждый щелчок обрабатывается отдельно. Будьте уверены, что React выполняет пакетирование только тогда, когда это в целом безопасно. Это гарантирует, что, например, если первое нажатие кнопки отключает форму, второе нажатие не отправит ее снова.

## [Обновление одного и того же состояния несколько раз перед следующим рендерингом](#)

Это необычный вариант использования, но если вы хотите обновить одну и ту же переменную состояния несколько раз перед следующим рендерингом, вместо передачи следующего значения состояния, например `setNumber(number 1)`, вы можете передать функцию, которая вычисляет следующее состояние на основе предыдущего в очереди, например `setNumber(n => n + 1)`. Это способ сказать React «сделать что-то со значением состояния» вместо того, чтобы просто заменить его.

Попробуйте увеличить счетчик сейчас:

```jsx
// App.js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(n => n + 1);
          setNumber(n => n + 1);
          setNumber(n => n + 1);
        }}>
        +3
      </button>
    </>
  );
}
```

Здесь `n => n + 1` называется функцией обновления. Когда вы передаете ее в сеттер состояния:

1. React ставит эту функцию в очередь на обработку после того, как будет выполнен весь остальной код в обработчике событий.
2. Во время следующего рендеринга React проходит по очереди и выдает вам окончательное обновленное состояние.

```jsx
setNumber(n => n + 1);
setNumber(n => n + 1);
setNumber(n => n + 1);
```

Вот как React работает с этими строками кода при выполнении обработчика событий:

1. `setNumber(n => n + 1)`: `n => n + 1` это функция. React добавляет ее в очередь.
2. `setNumber(n => n + 1)`: `n => n + 1` это функция. React добавляет ее в очередь.
3. `setNumber(n => n + 1)`: `n => n + 1` это функция. React добавляет ее в очередь.

Когда вы вызываете `useState` во время следующего рендеринга, React проходит по очереди. Предыдущее состояние `number` было `0`, поэтому React передает его первой функции обновления в качестве аргумента `n`. Затем React берет возвращаемое значение вашей предыдущей функции обновления и передает его следующей функции обновления в качестве `n` и так далее:

| обновление в очереди |  n  | возвращается |
| :------------------: | :-: | :----------: |
|     `n => n + 1`     | `0` | `0 + 1 = 1`  |
|     `n => n + 1`     | `1` | `1 + 1 = 2`  |
|     `n => n + 1`     | `2` | `2 + 1 = 3`  |

React сохраняет `3` как конечный результат и возвращает его из `useState`.

Вот почему нажатие «+3» в приведенном выше примере корректно увеличивает значение на 3.

### [Что произойдет, если вы обновите состояние после его замены](#)

А как насчет этого обработчика событий? Как вы думаете, какое `number` будет в следующем рендере?

```jsx
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
}}>
```

```jsx
// App.js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setNumber(n => n + 1);
        }}>
        Increase the number
      </button>
    </>
  );
}
```

Вот что этот обработчик событий сообщает React:

1. `setNumber(number + 5)`: `number` равно `0`, поэтому `setNumber(0 + 5)`. React добавляет «заменить на `5`» в свою очередь.
2. `setNumber(n => n + 1)`: `n => n + 1` — это функция обновления. React добавляет эту функцию в свою очередь.

Во время следующего рендеринга React проходит через очередь состояний:

| обновление в очереди |           n            | возвращается |
| :------------------: | :--------------------: | :----------: |
|  "заменить на `5`"   | `0` (неиспользованный) |     `5`      |
|     `n => n + 1`     |          `5`           | `5 + 1 = 6`  |

React сохраняет `6` как конечный результат и возвращает его из `useState`.

### Примечание

Вы могли заметить, что `setState(5)` на самом деле работает как `setState(n => 5)`, но `n` не используется!

### [Что произойдет, если заменить состояние после его обновления](#)

Давайте попробуем еще один пример. Как вы думаете, какое `number` будет в следующем рендере?

```jsx
// App.js
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
  setNumber(42);
}}>
```

```jsx
// App.js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setNumber(n => n + 1);
          setNumber(42);
        }}>
        Increase the number
      </button>
    </>
  );
}
```

Вот как React работает с этими строками кода при выполнении этого обработчика событий:

1. `setNumber(number + 5)`: `number` равно `0`, поэтому `setNumber(0 + 5)`. React добавляет «заменить на 5» в свою очередь.
2. `setNumber(n => n + 1)`: `n => n + 1` — это функция обновления. React добавляет эту функцию в свою очередь.
3. `setNumber(42)`: React добавляет «заменить на 42» в свою очередь.

Во время следующего рендеринга React проходит через очередь состояний:

| обновление в очереди |           n            | возвращается |
| :------------------: | :--------------------: | :----------: |
|  "заменить на `5`"   | `0` (неиспользованный) |     `5`      |
|     `n => n + 1`     |          `5`           | `5 + 1 = 6`  |
|  "заменить на `42`"  | `6` (неиспользованный) |     `42`     |

Затем React сохраняет `42` как конечный результат и возвращает его из `useState`.

Подводя итог, вот как можно представить, что вы передаете в сеттер состояния `setNumber`:

- **Функция обновления** (например, `n => n + 1`) добавляется в очередь.
- **Любое другое значение** (например, число `5`) добавляет «заменить на `5`» в очередь, игнорируя то, что уже находится в очереди.

После завершения обработчика событий React запустит повторный рендеринг. Во время повторного рендеринга React обработает очередь. Функции обновления запускаются во время рендеринга, поэтому функции обновления должны быть [чистыми](https://react.dev/learn/keeping-components-pure) и возвращать только результат. Не пытайтесь устанавливать состояние изнутри них или запускать другие побочные эффекты. В строгом режиме React дважды запустит каждую функцию обновления (но отбросит второй результат), чтобы помочь вам найти ошибки.

### [Соглашение об именовании](#)

Аргумент функции обновления принято называть по первым буквам соответствующей переменной состояния:

```jsx
setEnabled(e => !e);
setLastName(ln => ln.reverse());
setFriendCount(fc => fc * 2);
```

Если вы предпочитаете более подробный код, другим распространенным соглашением является повторение полного имени переменной состояния, например `setEnabled(enabled => !enabled)`, или использование префикса, например `setEnabled(prevEnabled => !prevEnabled)`.

## [Резюме](#)

- Установка состояния не изменяет переменную в существующем рендере, но запрашивает новый рендер.
- React обрабатывает обновления состояния после того, как обработчики событий завершили работу. Это называется batching (пакетирование).
- Чтобы обновить некоторое состояние несколько раз за одно событие, можно использовать функцию обновления `setNumber(n => n + 1)`.

## [Следующий шаг](#)

- Продолжение - [Глава 6. Обновление объектов в состоянии](<./6. Updating Objects in State.md>)
