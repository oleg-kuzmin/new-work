# [Выбор структуры состояния](../../index.md)

- [Обзор](#обзор)
- [Резюме](#резюме)
- [Следующие шаги](#следующие-шаги)

## [Обзор](#)

**Правильное структурирование состояния может стать причиной разницы между компонентом, который приятно изменять и отлаживать, и компонентом, который является постоянным источником ошибок. Вот несколько советов, которые следует учитывать при структурировании состояния.**

### Ты выучишь

- Когда использовать одну или несколько переменных состояния
- Чего следует избегать при организации состояния
- Как решить распространенные проблемы со структурой состояния

## [Принципы структурирования состояния](#)

Когда вы пишете компонент, который содержит некоторое состояние, вам придется сделать выбор относительно того, сколько переменных состояния использовать и какой должна быть форма их данных. Хотя возможно писать правильные программы даже с неоптимальной структурой состояния, есть несколько принципов, которые могут помочь вам сделать лучший выбор:

1. **Группируйте связанные состояния.** Если вы всегда обновляете две или более переменных состояния одновременно, рассмотрите возможность их объединения в одну переменную состояния.
2. **Избегайте противоречий в состоянии.** Когда состояние структурировано таким образом, что несколько его частей могут противоречить и «не соглашаться» друг с другом, вы оставляете место для ошибок. Старайтесь этого избегать.
3. **Избегайте избыточного состояния.** Если вы можете вычислить некоторую информацию из props компонента или его существующих переменных состояния во время рендеринга, вам не следует помещать эту информацию в состояние этого компонента.
4. **Избегайте дублирования в состоянии.** Когда одни и те же данные дублируются между несколькими переменными состояния или внутри вложенных объектов, их трудно синхронизировать. Уменьшайте дублирование, когда можете.
5. **Избегайте глубоко вложенных состояний.** Глубоко иерархическое состояние не очень удобно обновлять. По возможности предпочитайте структурировать состояние плоским способом.

Цель этих принципов — сделать состояние простым для обновления без внесения ошибок. Удаление избыточных и дублирующихся данных из состояния помогает гарантировать, что все его части остаются синхронизированными. Это похоже на то, как инженер базы данных может захотеть [«нормализовать» структуру базы данных](https://docs.microsoft.com/en-us/office/troubleshoot/access/database-normalization-description), чтобы уменьшить вероятность ошибок. Перефразируя Альберта Эйнштейна, **«Сделайте свое состояние настолько простым, насколько это возможно, — но не проще».**

Теперь давайте посмотрим, как эти принципы применяются на практике.

## [Группировка связанных состояний](#)

Иногда вы можете быть не уверены в том, следует ли использовать одну или несколько переменных состояния.

Стоит ли это делать?

```jsx
const [x, setX] = useState(0);
const [y, setY] = useState(0);
```

Или это?

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });
```

Технически, вы можете использовать любой из этих подходов. Но **если какие-то две переменные состояния всегда изменяются вместе, может быть хорошей идеей объединить их в одну переменную состояния.** Тогда вы не забудете всегда поддерживать их синхронизацию, как в этом примере, где перемещение курсора обновляет обе координаты красной точки:

```jsx
// App.js
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={e => {
        setPosition({
          x: e.clientX,
          y: e.clientY,
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'red',
          borderRadius: '50%',
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

Другой случай, когда вы группируете данные в объект или массив, — это когда вы не знаете, сколько частей состояния вам понадобится. Например, это полезно, когда у вас есть форма, в которую пользователь может добавлять пользовательские поля.

### Внимание!

> Если ваша переменная состояния является объектом, помните, что [вы не можете обновить только одно поле в нем](https://react.dev/learn/updating-objects-in-state) без явного копирования других полей. Например, вы не можете сделать `setPosition({ x: 100 })` в приведенном выше примере, потому что у него вообще не будет свойства `y`! Вместо этого, если вы хотите установить только `x`, вы должны либо сделать `setPosition({ ...position, x: 100 })`, либо разделить их на две переменные состояния и сделать `setX(100)`.

## [Избегайте противоречий в состоянии](#)

Вот форма обратной связи для отеля с переменными состояния `isSending` и `isSent`:

```jsx
// App.js
import { useState } from 'react';

export default function FeedbackForm() {
  const [text, setText] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [isSent, setIsSent] = useState(false);

  async function handleSubmit(e) {
    e.preventDefault();
    setIsSending(true);
    await sendMessage(text);
    setIsSending(false);
    setIsSent(true);
  }

  if (isSent) {
    return <h1>Thanks for feedback!</h1>;
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea disabled={isSending} value={text} onChange={e => setText(e.target.value)} />
      <br />
      <button disabled={isSending} type="submit">
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Сделайте вид, что отправляете сообщение.
function sendMessage(text) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  });
}
```

Хотя этот код работает, он оставляет дверь открытой для «невозможных» состояний. Например, если вы забудете вызвать `setIsSent` и `setIsSending` вместе, вы можете оказаться в ситуации, когда `isSending` и `isSent` будут истинны одновременно. Чем сложнее ваш компонент, тем сложнее понять, что произошло.

**Поскольку `isSending` и `isSent` никогда не должны быть `true` одновременно, лучше заменить их одной переменной состояния `status`, которая может принимать одно из трех допустимых состояний:** `'typing' (начальное)`, `'sending' (отправка)`, and `'sent' (отправлено)`:

```jsx
import { useState } from 'react';

export default function FeedbackForm() {
  const [text, setText] = useState('');
  const [status, setStatus] = useState('typing');

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus('sending');
    await sendMessage(text);
    setStatus('sent');
  }

  const isSending = status === 'sending';
  const isSent = status === 'sent';

  if (isSent) {
    return <h1>Thanks for feedback!</h1>;
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea disabled={isSending} value={text} onChange={e => setText(e.target.value)} />
      <br />
      <button disabled={isSending} type="submit">
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Сделайте вид, что отправляете сообщение.
function sendMessage(text) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  });
}
```

Вы все еще можете объявить некоторые константы для удобства чтения:

```jsx
const isSending = status === 'sending';
const isSent = status === 'sent';
```

Но они не являются переменными состояния, поэтому вам не нужно беспокоиться о том, что они выйдут из синхронизации друг с другом.

## [Избегайте избыточного состояния](#)

Если вы можете вычислить некоторую информацию из свойств компонента или его существующих переменных состояния во время рендеринга, вам не следует помещать эту информацию в состояние этого компонента.

Например, возьмем эту форму. Она работает, но можете ли вы найти в ней какое-либо избыточное состояние?

```jsx
// App.js
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState('');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
    setFullName(e.target.value + ' ' + lastName);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
    setFullName(firstName + ' ' + e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name: <input value={firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name: <input value={lastName} onChange={handleLastNameChange} />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}
```

Эта форма имеет три переменные состояния: `firstName`, `lastName` и `fullName`. Однако `fullName` избыточна. **Вы всегда можете вычислить `fullName` из `firstName` и `lastName` во время рендеринга, поэтому удалите ее из состояния.**

Вот как это можно сделать:

```jsx
// App.js
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  const fullName = firstName + ' ' + lastName;

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name: <input value={firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name: <input value={lastName} onChange={handleLastNameChange} />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}
```

Здесь `fullName` не является переменной состояния. Вместо этого она вычисляется во время рендеринга:

```jsx
const fullName = firstName + ' ' + lastName;
```

В результате обработчикам изменений не нужно делать ничего особенного для его обновления. Когда вы вызываете `setFirstName` или `setLastName`, вы запускаете повторный рендеринг, а затем следующий `fullName` будет рассчитан из свежих данных.

### Не копируйте props в состоянии

> Типичным примером избыточного состояния является такой код:

```jsx
function Message({ messageColor }) {
  const [color, setColor] = useState(messageColor);
}
```

> Здесь переменная состояния `color` инициализируется свойством `messageColor`. Проблема в том, что **если родительский компонент позже передаст другое значение `messageColor` (например, `'red'` вместо `'blue'`), переменная состояния цвета не будет обновлена!** Состояние инициализируется только во время первого рендера.

> Вот почему "зеркальное" отображение некоторого свойства в переменной состояния может привести к путанице. Вместо этого используйте свойство `messageColor` непосредственно в коде. Если вы хотите дать ему более короткое имя, используйте константу:

```jsx
function Message({ messageColor }) {
  const color = messageColor;
}
```

> Таким образом, он не рассинхронизируется с параметром, переданным из родительского компонента.

> "Отзеркаливание" пропсов в состояние имеет смысл только тогда, когда вы хотите игнорировать все обновления для конкретного пропса. По соглашению, имя пропса следует начинать с `initial` или `default`, чтобы прояснить, что его новые значения игнорируются:

```jsx
function Message({ initialColor }) {
  // Переменная состояния `color` содержит *первое* значение `initialColor`.
  // Дальнейшие изменения свойства `initialColor` игнорируются.
  const [color, setColor] = useState(initialColor);
}
```

## [Избегайте дублирования в состоянии](#)

Этот компонент списка меню позволяет вам выбрать один вариант закуски для путешествия из нескольких:

```jsx
// App.js
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(items[0]);

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map(item => (
          <li key={item.id}>
            {item.title}{' '}
            <button
              onClick={() => {
                setSelectedItem(item);
              }}>
              Choose
            </button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

В настоящее время он сохраняет выбранный элемент как объект в переменной состояния `selectedItem`. Однако это не очень хорошо: **содержимое `selectedItem` является тем же объектом, что и один из элементов в списке `items`**. Это означает, что информация о самом элементе дублируется в двух местах.

Почему это проблема? Давайте сделаем каждый элемент редактируемым:

```jsx
// App.js
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(items[0]);

  function handleItemChange(id, e) {
    setItems(
      items.map(item => {
        if (item.id === id) {
          return {
            ...item,
            title: e.target.value,
          };
        } else {
          return item;
        }
      })
    );
  }

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={e => {
                handleItemChange(item.id, e);
              }}
            />{' '}
            <button
              onClick={() => {
                setSelectedItem(item);
              }}>
              Choose
            </button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

Обратите внимание, что если вы сначала нажмете "Choose" на элементе, а затем отредактируете его, **ввод обновится, но метка внизу не отразит изменения.** Это потому, что у вас дублированное состояние, и вы забыли обновить `selectedItem`.

Хотя вы также можете обновить `selectedItem`, более простым решением будет удаление дублирования. В этом примере вместо объекта `selectedItem` (который создает дублирование с объектами внутри `items`) вы удерживаете `selectedId` в состоянии, а затем получаете `selectedItem`, выполняя поиск элемента с этим ID в массиве `items`:

```jsx
// App.js
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedId, setSelectedId] = useState(0);

  const selectedItem = items.find(item => item.id === selectedId);

  function handleItemChange(id, e) {
    setItems(
      items.map(item => {
        if (item.id === id) {
          return {
            ...item,
            title: e.target.value,
          };
        } else {
          return item;
        }
      })
    );
  }

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={e => {
                handleItemChange(item.id, e);
              }}
            />{' '}
            <button
              onClick={() => {
                setSelectedId(item.id);
              }}>
              Choose
            </button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

Раньше состояние дублировалось следующим образом:

- `items = [{ id: 0, title: 'pretzels'}, ...]`
- `selectedItem = {id: 0, title: 'pretzels'}`

Но после изменения это выглядит так:

- `items = [{ id: 0, title: 'pretzels'}, ...]`
- `selectedId = 0`

Дублирование исчезло, и осталось только основное состояние!

Теперь, если вы отредактируете выбранный элемент, сообщение ниже немедленно обновится. Это потому, что `setItems` запускает повторный рендеринг, а `items.find(...)` найдет элемент с обновленным заголовком. Вам не нужно было удерживать выбранный элемент в состоянии, потому что важен только выбранный ID. Остальное можно было вычислить во время рендера.

## [Избегайте глубоко вложенных состояний](#)
