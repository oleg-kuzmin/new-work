# [Поддержание чистоты компонентов](../../index.md)

- [Обзор](#обзор)
- [Чистота: Компоненты как формулы](#чистота-компоненты-как-формулы)
- [Побочные эффекты: (не)преднамеренные последствия](#побочные-эффекты-непреднамеренные-последствия)
  - [Локальная мутация: маленький секрет вашего компонента](#локальная-мутация-маленький-секрет-вашего-компонента)
- [Где вы можете вызвать побочные эффекты](#где-вы-можете-вызвать-побочные-эффекты)
- [Резюме](#резюме)
- [Следующие шаги](#следующие-шаги)

## [Обзор](#)

**Некоторые функции JavaScript являются чистыми. Чистые функции выполняют только вычисления и ничего больше. Строго записывая свои компоненты только как чистые функции, вы можете избежать целого класса непонятных ошибок и непредсказуемого поведения по мере роста вашей кодовой базы. Однако, чтобы получить эти преимущества, есть несколько правил, которым вы должны следовать.**

### Ты выучишь

- Что такое чистота и как она помогает избежать ошибок
- Как сохранить чистоту компонентов, не внося изменений на этапе рендеринга
- Как использовать строгий режим для поиска ошибок в компонентах

## [Чистота: Компоненты как формулы](#)

В информатике (и особенно в мире функционального программирования) [чистая функция](https://wikipedia.org/wiki/Pure_function) — это функция со следующими характеристиками:

- **Она занимается своими делами.** Она не изменяет никаких объектов или переменных, которые существовали до ее вызова.
- **Одинаковые входные данные, такой же результат.** При тех же входных данных чистая функция всегда должна возвращать тот же результат.

Возможно, вы уже знакомы с одним примером чистых функций: формулами в математике.

Рассмотрим эту математическую формулу: `y = 2x`.

Если `x = 2`, то `y = 4`. Всегда.

Если `x = 3`, то `y = 6`. Всегда.

Если `x = 3`, то `y` не будет иногда равняться `9` или `–1` или `2,5` в зависимости от времени суток или состояния фондового рынка.

Если `y = 2x` и `x = 3`, `y` всегда будет равен `6`.

Если бы мы превратили это в функцию JavaScript, это выглядело бы так:

```jsx
function double(number) {
  return 2 * number;
}
```

В приведенном выше примере `double` — чистая функция. Если вы передадите ей `3`, она вернет `6`. Всегда.

React разработан вокруг этой концепции. React предполагает, что каждый компонент, который вы пишете, является чистой функцией. Это означает, что компоненты React, которые вы пишете, должны всегда возвращать один и тот же JSX, учитывая одни и те же входные данные:

```jsx
// App.js
function Recipe({ drinkers }) {
  return (
    <ol>
      <li>Boil {drinkers} cups of water.</li>
      <li>
        Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.
      </li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}

export default function App() {
  return (
    <section>
      <h1>Spiced Chai Recipe</h1>
      <h2>For two</h2>
      <Recipe drinkers={2} />
      <h2>For a gathering</h2>
      <Recipe drinkers={4} />
    </section>
  );
}
```

Когда вы передаете `drinkers={2}` в `Recipe`, он вернет JSX, содержащий `2 cups of water`. Всегда.

Прямо как математическая формула.

Вы можете думать о своих компонентах как о рецептах: если вы следуете им и не вводите новые ингредиенты в процессе приготовления, вы будете получать одно и то же блюдо каждый раз. Это «блюдо» — JSX, который компонент предоставляет React для [рендеринга](https://react.dev/learn/render-and-commit).

![image](<./8.1. Keeping Components Pure.png>)

## [Побочные эффекты: (не)преднамеренные последствия](#)

Процесс рендеринга React всегда должен быть чистым. Компоненты должны возвращать только свой JSX и не изменять никаких объектов или переменных, которые существовали до рендеринга — это сделает их нечистыми!

Вот компонент, который **НАРУШАЕТ** это правило:

```jsx
// App.js
let guest = 0;

function Cup() {
  // Плохо: изменение существующей переменной!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

Этот компонент читает и записывает переменную `guest`, объявленную вне его. Это означает, что вызов этого компонента несколько раз даст другой JSX! И более того, если другие компоненты читают переменную `guest`, они также дадут другой JSX, в зависимости от того, когда они были отрисованы! Это непредсказуемо.

Возвращаясь к нашей формуле `y = 2x`, теперь даже если `x = 2`, мы не можем быть уверены, что `y = 4`. Наши тесты могут провалиться, наши пользователи будут сбиты с толку, самолеты будут падать с неба — вы можете видеть, как это приведет к запутанным ошибкам!

Вы можете исправить этот компонент, [передав guest в качестве props](https://react.dev/learn/passing-props-to-a-component):

```jsx
// App.js
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

Теперь ваш компонент чистый, так как возвращаемый им JSX зависит только от свойства `guest`.

В общем, не стоит ожидать, что ваши компоненты будут отображаться в каком-то определенном порядке. Неважно, вызываете ли вы `y = 2x` до или после `y = 5x`: обе формулы будут решаться независимо друг от друга. Точно так же каждый компонент должен «думать сам за себя» и не пытаться координировать работу с другими или зависеть от них во время отображения. Отображение похоже на школьный экзамен: каждый компонент должен самостоятельно вычислять JSX!

### Обнаружение нечистых вычислений с помощью StrictMode

> Хотя вы, возможно, еще не использовали их все, в React есть три типа входных данных, которые вы можете читать во время рендеринга: [props](https://react.dev/learn/passing-props-to-a-component), [state](https://react.dev/learn/state-a-components-memory) и [context](https://react.dev/learn/passing-data-deeply-with-context). Вы всегда должны рассматривать эти входные данные как доступные только для чтения.

> Когда вы хотите что-то изменить в ответ на пользовательский ввод, вы должны [установить состояние](https://react.dev/learn/state-a-components-memory) вместо записи в переменную. Вы никогда не должны изменять уже существующие переменные или объекты, пока ваш компонент рендерится.

> React предлагает `Strict Mode`, в котором он вызывает функцию каждого компонента дважды во время разработки. Вызывая функции компонента дважды, строгий режим помогает находить компоненты, которые нарушают эти правила.

> Обратите внимание, как в исходном примере отображались «Guest #2», «Guest #4» и «Guest #6» вместо «Guest #1», «Guest #2» и «Guest #3». Исходная функция была нечистой, поэтому ее двойной вызов сломал ее. Но исправленная чистая версия работает, даже если функция вызывается дважды каждый раз. Чистые функции только вычисляют, поэтому их двойной вызов ничего не изменит — так же, как двойной вызов `double(2)` не меняет возвращаемое значение, а решение `y = 2x` дважды не меняет то, чем будет `y`. Те же входные данные, те же выходные данные. Всегда.

> `Strict Mode` не влияет на production, поэтому он не замедлит работу приложения для ваших пользователей. Чтобы выбрать `Strict Mode`, вы можете обернуть свой корневой компонент в `<React.StrictMode>`. Некоторые фреймворки делают это по умолчанию.

### [Локальная мутация: маленький секрет вашего компонента](#)

В приведенном выше примере проблема заключалась в том, что компонент изменил существующую переменную во время рендеринга. Это часто называют «мутацией», чтобы звучать еще страшнее. Чистые функции не мутируют переменные за пределами области действия функции или объекты, созданные до вызова — это делает их нечистыми!

Однако, совершенно нормально изменять переменные и объекты, которые вы только что создали во время рендеринга. В этом примере вы создаете массив `[]`, назначаете его переменной `cups`, а затем помещаете в него методом `push` дюжину `cups`:

```jsx
// App.js
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

Если бы переменная `cups` или массив `[]` были созданы вне функции `TeaGathering`, это было бы огромной проблемой! Вы бы изменили уже существующий объект, помещая элементы в этот массив.

Однако это нормально, потому что вы создали их во время того же рендеринга, внутри `TeaGathering`. Никакой код за пределами `TeaGathering` никогда не узнает, что произошло. Это называется «локальная мутация» — это как маленький секрет вашего компонента.

## [Где вы можете вызвать побочные эффекты](#)

Хотя функциональное программирование в значительной степени опирается на чистоту, в какой-то момент где-то что-то должно измениться. Это своего рода смысл программирования! Эти изменения — обновление экрана, запуск анимации, изменение данных — называются побочными эффектами. Это то, что происходит «на стороне», а не во время рендеринга.

В React побочные эффекты обычно относятся к [обработчикам событий](https://react.dev/learn/responding-to-events). Обработчики событий — это функции, которые React запускает, когда вы выполняете какое-либо действие, например, когда вы нажимаете кнопку. Несмотря на то, что обработчики событий определены внутри вашего компонента, они не запускаются во время рендеринга! Поэтому обработчики событий не должны быть чистыми.

Если вы исчерпали все другие варианты и не можете найти правильный обработчик событий для вашего побочного эффекта, вы все равно можете прикрепить его к возвращенному JSX с помощью вызова [useEffect](https://react.dev/reference/react/useEffect) в вашем компоненте. Это говорит React выполнить его позже, после рендеринга, когда побочные эффекты разрешены. Однако этот подход должен быть вашим последним средством.

Когда это возможно, старайтесь выразить свою логику только с помощью рендеринга. Вы удивитесь, как далеко это может вас завести!

### Почему React заботится о чистоте?

> Написание чистых функций требует некоторой привычки и дисциплины. Но это также открывает замечательные возможности:

> - Ваши компоненты могут работать в другой среде — например, на сервере! Поскольку они возвращают один и тот же результат для одних и тех же входных данных, один компонент может обслуживать множество пользовательских запросов.
> - Вы можете улучшить производительность, [пропуская компоненты рендеринга](https://react.dev/reference/react/memo), чьи входные данные не изменились. Это безопасно, поскольку чистые функции всегда возвращают одинаковые результаты, поэтому их можно безопасно кэшировать.
> - Если некоторые данные изменяются в середине рендеринга глубокого дерева компонентов, React может перезапустить рендеринг, не тратя время на завершение устаревшего рендеринга. Чистота позволяет безопасно останавливать вычисления в любое время.

> Каждая новая функция React, которую мы создаем, использует преимущества чистоты. От извлечения данных до анимации и производительности, сохранение чистоты компонентов раскрывает силу парадигмы React.

## [Резюме](#)

- Компонент должен быть чистым, т.е.
  - Он занимается своими делами. Он не должен изменять никакие объекты или переменные, которые существовали до рендеринга.
  - Те же входы, тот же выход. При тех же входах компонент всегда должен возвращать тот же JSX.
- Рендеринг может произойти в любое время, поэтому компоненты не должны зависеть от последовательности рендеринга друг друга.
- Вам не следует изменять какие-либо входные данные, которые ваши компоненты используют для рендеринга. Это включает в себя `props`, `state` и `context`. Чтобы обновить экран, [установите состояние](https://react.dev/learn/state-a-components-memory) вместо изменения существующих объектов.
- Стремитесь выразить логику вашего компонента в возвращаемом JSX. Когда вам нужно «изменить что-то», вы обычно хотите сделать это в обработчике событий. В крайнем случае вы можете использовать `useEffect`.
- Написание чистых функций требует некоторой практики, но это раскрывает всю мощь парадигмы React.

## [Следующие шаги](#)

- Продолжение - [Глава 9. Ваш UI как дерево](<./9. Your UI as a tree.md>)
