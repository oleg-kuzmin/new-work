# [Реакция на входные данные с помощью состояния](../../index.md)

- [Обзор](#обзор)
- [Думаем об UI декларативно](#думаем-об-ui-декларативно)
  - [Шаг 1: Определите различные визуальные состояния вашего компонента](#шаг-1-определите-различные-визуальные-состояния-вашего-компонента)
- [Резюме](#резюме)
- [Следующие шаги](#следующие-шаги)

## [Обзор](#)

**React предоставляет декларативный способ манипулирования UI. Вместо того, чтобы манипулировать отдельными частями UI напрямую, вы описываете различные состояния, в которых может находиться ваш компонент, и переключаетесь между ними в ответ на ввод данных пользователем. Это похоже на то, как дизайнеры думают об UI.**

### Ты выучишь

- Чем декларативное программирование UI отличается от императивного программирования UI
- Как перечислить различные визуальные состояния, в которых может находиться ваш компонент
- Как вызвать изменения между различными визуальными состояниями из кода

## [Чем декларативный UI отличается от императивного](#)

Когда вы проектируете взаимодействия UI, вы, вероятно, думаете о том, как UI меняется в ответ на действия пользователя. Рассмотрим форму, которая позволяет пользователю отправлять ответ:

- Когда вы вводите что-либо в форму, кнопка "Submit" становится активной.
- При нажатии "Submit" и форма, и кнопка становятся неактивными, и появляется прелоадер spinner.
- Если сетевой запрос выполнен успешно, форма скрывается и появляется сообщение "Thank you".
- Если сетевой запрос не выполняется, появляется сообщение об ошибке, и форма снова становится доступной.

В императивном программировании вышесказанное напрямую соответствует тому, как вы реализуете взаимодействие. Вам нужно написать точные инструкции для управления пользовательским интерфейсом в зависимости от того, что только что произошло. Вот еще один способ подумать об этом: представьте, что вы едете рядом с кем-то в машине и говорите ему шаг за шагом, куда ехать.

Он не знает, куда вы хотите поехать, он просто следует вашим командам. (А если вы неправильно поняли направление, вы окажетесь не в том месте!) Это называется императивным, потому что вам нужно «командовать» каждым элементом, от счетчика до кнопки, сообщая компьютеру, как обновить пользовательский интерфейс.

В этом примере императивного программирования пользовательского интерфейса форма создается без React. Она использует только браузерный [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model):

```html
<!-- index.html -->
<form id="form">
  <h2>City quiz</h2>
  <p>What city is located on two continents?</p>
  <textarea id="textarea"></textarea>
  <br />
  <button id="button" disabled>Submit</button>
  <p id="loading" style="display: none">Loading...</p>
  <p id="error" style="display: none; color: red;"></p>
</form>
<h1 id="success" style="display: none">That's right!</h1>
```

```js
// index.js
async function handleFormSubmit(e) {
  e.preventDefault();
  disable(textarea);
  disable(button);
  show(loadingMessage);
  hide(errorMessage);
  try {
    await submitForm(textarea.value);
    show(successMessage);
    hide(form);
  } catch (err) {
    show(errorMessage);
    errorMessage.textContent = err.message;
  } finally {
    hide(loadingMessage);
    enable(textarea);
    enable(button);
  }
}

function handleTextareaChange() {
  if (textarea.value.length === 0) {
    disable(button);
  } else {
    enable(button);
  }
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

function enable(el) {
  el.disabled = false;
}

function disable(el) {
  el.disabled = true;
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (answer.toLowerCase() === 'istanbul') {
        resolve();
      } else {
        reject(new Error('Good guess but a wrong answer. Try again!'));
      }
    }, 1500);
  });
}

let form = document.getElementById('form');
let textarea = document.getElementById('textarea');
let button = document.getElementById('button');
let loadingMessage = document.getElementById('loading');
let errorMessage = document.getElementById('error');
let successMessage = document.getElementById('success');
form.onsubmit = handleFormSubmit;
textarea.oninput = handleTextareaChange;
```

Манипулирование UI императивно работает достаточно хорошо для отдельных примеров, но становится экспоненциально сложнее управлять в более сложных системах. Представьте себе обновление страницы, полной различных форм, таких как эта. Добавление нового элемента UI или нового взаимодействия потребует тщательной проверки всего существующего кода, чтобы убедиться, что вы не внесли ошибку (например, забыли показать или скрыть что-то).

React был создан для решения этой проблемы.

В React вы не управляете пользовательским интерфейсом напрямую, то есть вы не включаете, не отключаете, не показываете и не скрываете компоненты напрямую. Вместо этого вы объявляете, что хотите показать, а React вычисляет, как обновить пользовательский интерфейс. Представьте, что вы садитесь в такси и говорите водителю, куда вы хотите ехать, вместо того, чтобы сказать ему, где именно повернуть. Задача водителя — доставить вас туда, и он может даже знать некоторые короткие пути, которые вы не учли!

## [Думаем об UI декларативно](#)

Выше вы увидели, как реализовать форму императивно. Чтобы лучше понять, как думать в React, вы пройдете через повторную реализацию этого пользовательского интерфейса в React ниже:

1. Определите различные визуальные состояния вашего компонента
2. Определите, что вызывает эти изменения состояния
3. Представьте состояние в памяти с помощью `useState`
4. Удалите все несущественные переменные состояния
5. Подключите обработчики событий для установки состояния

### [Шаг 1: Определите различные визуальные состояния вашего компонента](#)

В информатике вы можете услышать о [«машине состояний»](https://en.wikipedia.org/wiki/Finite-state_machine), находящейся в одном из нескольких «состояний». Если вы работаете с дизайнером, вы могли видеть макеты для разных «визуальных состояний». React находится на стыке дизайна и информатики, поэтому обе эти идеи являются источниками вдохновения.

Во-первых, вам необходимо визуализировать все различные «состояния» пользовательского интерфейса, которые может увидеть пользователь:

- **Empty (Пустое)** : в форме отключена кнопка "Submit".
- **Typing (Ввод текста)** : в форме есть активная кнопка "Submit".
- **Submitting (Отправка)** : форма полностью отключена. Спиннер отображается.
- **Success (Успех)** : вместо формы отображается сообщение "Thank you".
- **Error (Ошибка)** : то же, что и состояние "Typing", но с дополнительным сообщением об ошибке.

Как и дизайнер, вы захотите «сделать макет» или создать «макеты» для разных состояний, прежде чем добавлять логику. Например, вот макет только для визуальной части формы. Этот макет управляется свойством `status` со значением по умолчанию `'empty'`:

```jsx
// App.js
export default function Form({ status = 'empty' }) {
  if (status === 'success') {
    return <h1>That's right!</h1>;
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>In which city is there a billboard that turns air into drinkable water?</p>
      <form>
        <textarea />
        <br />
        <button>Submit</button>
      </form>
    </>
  );
}
```

Вы можете назвать этот prop как угодно, наименование не имеет значения. Попробуйте изменить `status = 'empty'` на `status = 'success'`, чтобы увидеть сообщение об успешном выполнении. Имитация позволяет быстро перебирать пользовательский интерфейс, прежде чем подключать какую-либо логику. Вот более развернутый прототип того же компонента, все еще «контролируемый» prop `status`:

```jsx
// App.js
export default function Form({
  // Попробуйте 'submitting', 'error', 'success':
  status = 'empty',
}) {
  if (status === 'success') {
    return <h1>That's right!</h1>;
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>In which city is there a billboard that turns air into drinkable water?</p>
      <form>
        <textarea disabled={status === 'submitting'} />
        <br />
        <button disabled={status === 'empty' || status === 'submitting'}>Submit</button>
        {status === 'error' && <p className="Error">Good guess but a wrong answer. Try again!</p>}
      </form>
    </>
  );
}
```

### Отображение множества визуальных состояний одновременно
