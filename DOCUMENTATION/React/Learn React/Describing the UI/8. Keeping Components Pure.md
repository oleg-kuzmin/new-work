# [Поддержание чистоты компонентов](../../index.md)

- [Обзор](#обзор)
- [Резюме](#резюме)
- [Следующие шаги](#следующие-шаги)

## [Обзор](#поддержание-чистоты-компонентов)

Некоторые функции JavaScript являются чистыми. Чистые функции выполняют только вычисления и ничего больше. Строго записывая свои компоненты только как чистые функции, вы можете избежать целого класса непонятных ошибок и непредсказуемого поведения по мере роста вашей кодовой базы. Однако, чтобы получить эти преимущества, есть несколько правил, которым вы должны следовать.

### [Ты выучишь](#поддержание-чистоты-компонентов)

- Что такое чистота и как она помогает избежать ошибок
- Как сохранить чистоту компонентов, не внося изменений на этапе рендеринга
- Как использовать строгий режим для поиска ошибок в компонентах

## [Чистота: Компоненты как формулы](#поддержание-чистоты-компонентов)

В информатике (и особенно в мире функционального программирования) [чистая функция](https://wikipedia.org/wiki/Pure_function) — это функция со следующими характеристиками:

- **Она занимается своими делами.** Она не изменяет никаких объектов или переменных, которые существовали до ее вызова.
- **Одинаковые входные данные, такой же результат.** При тех же входных данных чистая функция всегда должна возвращать тот же результат.

Возможно, вы уже знакомы с одним примером чистых функций: формулами в математике.

Рассмотрим эту математическую формулу: `y = 2x`.

Если `x = 2`, то `y = 4`. Всегда.

Если `x = 3`, то `y = 6`. Всегда.

Если `x = 3`, то `y` не будет иногда равняться `9` или `–1` или `2,5` в зависимости от времени суток или состояния фондового рынка.

Если `y = 2x` и `x = 3`, `y` всегда будет равен `6`.

Если бы мы превратили это в функцию JavaScript, это выглядело бы так:

```jsx
function double(number) {
  return 2 * number;
}
```

В приведенном выше примере `double` — чистая функция. Если вы передадите ей `3`, она вернет `6`. Всегда.

React разработан вокруг этой концепции. React предполагает, что каждый компонент, который вы пишете, является чистой функцией. Это означает, что компоненты React, которые вы пишете, должны всегда возвращать один и тот же JSX, учитывая одни и те же входные данные:

```jsx
// App.js
function Recipe({ drinkers }) {
  return (
    <ol>
      <li>Boil {drinkers} cups of water.</li>
      <li>
        Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.
      </li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}

export default function App() {
  return (
    <section>
      <h1>Spiced Chai Recipe</h1>
      <h2>For two</h2>
      <Recipe drinkers={2} />
      <h2>For a gathering</h2>
      <Recipe drinkers={4} />
    </section>
  );
}
```

Когда вы передаете `drinkers={2}` в `Recipe`, он вернет JSX, содержащий `2 cups of water`. Всегда.

Прямо как математическая формула.

Вы можете думать о своих компонентах как о рецептах: если вы следуете им и не вводите новые ингредиенты в процессе приготовления, вы будете получать одно и то же блюдо каждый раз. Это «блюдо» — JSX, который компонент предоставляет React для [рендеринга](https://react.dev/learn/render-and-commit).

![image](<../../images/8.1. Keeping Components Pure.png>)

## [Побочные эффекты: (не)преднамеренные последствия](#поддержание-чистоты-компонентов)
