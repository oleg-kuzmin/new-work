# [Реагирование на события](../../index.md)

- [Обзор](#обзор)
- [Резюме](#резюме)
- [Следующие шаги](#следующие-шаги)

## [Обзор](#)

**React позволяет добавлять обработчики событий в ваш JSX. Обработчики событий — это ваши собственные функции, которые будут запускаться в ответ на такие взаимодействия, как нажатие, наведение, фокусировка на полях ввода формы и т. д.**

### Ты выучишь

- Различные способы написания обработчика событий
- Как передать логику обработки событий из родительского компонента
- Как распространяются события и как их остановить

## [Добавление обработчиков событий](#)

Чтобы добавить обработчик событий, нужно сначала определить функцию, а затем [передать ее как props](https://react.dev/learn/passing-props-to-a-component) в соответствующий тег JSX. Например, вот кнопка, которая пока ничего не делает:

```jsx
// App.js
export default function Button() {
  return <button>I don't do anything</button>;
}
```

Вы можете сделать так, чтобы при нажатии пользователем появлялось сообщение, выполнив следующие три шага:

1. Объявите функцию `handleClick` внутри компонента `Button`.
2. Реализуйте логику внутри этой функции (используйте `alert` для отображения сообщения).
3. Добавьте `onClick={handleClick}` к `<button>` JSX.

```jsx
// App.js
export default function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return <button onClick={handleClick}>Click me</button>;
}
```

Вы определили функцию `handleClick`, а затем передали [ее как props](https://react.dev/learn/passing-props-to-a-component) в `<button>`. `handleClick` — это обработчик событий. Функции обработчика событий:

- Обычно определяются внутри ваших компонентов.
- Имеют имена, начинающиеся с `handle`, за которым следует название события.

По соглашению обработчики событий принято называть `handle`, за которым следует имя события. Вы часто будете видеть `onClick={handleClick}`, `onMouseEnter={handleMouseEnter}` и т. д.

В качестве альтернативы вы можете определить обработчик событий в JSX:

```jsx
<button onClick={function handleClick() {
  alert('You clicked me!');
}}>
```

Или, более кратко, с использованием стрелочной функции:

```jsx
<button onClick={() => {
  alert('You clicked me!');
}}>
```

Все эти стили эквивалентны. Встроенные обработчики событий удобны для коротких функций.

### Внимание!

> Функции, передаваемые обработчикам событий, должны передаваться, а не вызываться. Например:

> |   передача функции (правильно)   |    вызов функции (неправильно)     |
> | :------------------------------: | :--------------------------------: |
> | `<button onClick={handleClick}>` | `<button onClick={handleClick()}>` |

> Разница едва заметна. В первом примере функция `handleClick` передается как обработчик событий `onClick`. Это говорит React запомнить ее и вызывать вашу функцию только тогда, когда пользователь нажимает кнопку.

> Во втором примере скобки `()` в конце `handleClick()` запускают функцию немедленно во время [рендеринга](https://react.dev/learn/render-and-commit), без каких-либо щелчков. Это происходит потому, что JavaScript внутри скобок `{}` в JSX выполняется [сразу](<(https://react.dev/learn/javascript-in-jsx-with-curly-braces)>).

> При написании встроенного кода та же ловушка проявляется по-другому:

> |      передача функции (правильно)       |    вызов функции (неправильно)    |
> | :-------------------------------------: | :-------------------------------: |
> | `<button onClick={() => alert('...')}>` | `<button onClick={alert('...')}>` |

> Передача такого встроенного кода не сработает при щелчке — он срабатывает каждый раз при рендеринге компонента:

```jsx
// Этот alert срабатывает при рендеринге компонента, а не при щелчке!
<button onClick={alert('You clicked me!')}>
```

> Если вы хотите определить обработчик событий инлайн, оберните его в анонимную функцию, например:

```jsx
<button onClick={() => alert('You clicked me!')}>
```

> Вместо того чтобы выполнять код внутри при каждом рендеринге, создается функция, которая будет вызвана позже.

> В обоих случаях вам нужно передать функцию:

> - `<button onClick={handleClick}>` передает функцию `handleClick`.
> - `<button onClick={() => alert('...')}>` передает функцию `() => alert('...')`.

> [Прочитайте больше о стрелочных функциях.](https://javascript.info/arrow-functions-basics)

### [Чтение props в обработчиках событий](#)

Поскольку обработчики событий объявляются внутри компонента, они имеют доступ к props компонента. Вот кнопка, которая при нажатии показывает предупреждение с prop `message`:

```jsx
// App.js
function AlertButton({ message, children }) {
  return <button onClick={() => alert(message)}>{children}</button>;
}

export default function Toolbar() {
  return (
    <div>
      <AlertButton message="Playing!">Play Movie</AlertButton>
      <AlertButton message="Uploading!">Upload Image</AlertButton>
    </div>
  );
}
```

Это позволяет этим двум кнопкам показывать разные сообщения. Попробуйте изменить сообщения, которые им передаются.

### [Передача обработчиков событий в качестве props](#)
