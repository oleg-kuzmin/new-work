# [Постановка в очередь серии обновлений состояния](../../index.md)

- [Обзор](#обзор)
- [Резюме](#резюме)
- [Следующие шаги](#следующие-шаги)

## [Обзор](#)

**Установка переменной состояния поставит в очередь другой рендер. Но иногда вам может понадобиться выполнить несколько операций со значением перед постановкой в ​​очередь следующего рендера. Для этого полезно понять, как React пакетирует обновления состояния.**

### Ты выучишь

- Что такое «batching (пакетирование)» и как React использует его для обработки множественных обновлений состояния
- Как применить несколько обновлений к одной и той же переменной состояния подряд

## [React обновляет состояние пакетами](#)

Можно было бы ожидать, что нажатие кнопки «+3» увеличит счетчик в три раза, поскольку он вызывает `setNumber(number + 1)` три раза:

```jsx
// App.js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}>
        +3
      </button>
    </>
  );
}
```

Однако, как вы, возможно, помните из предыдущего раздела, [значения состояний каждого рендера фиксированы](https://react.dev/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time), поэтому значение `number` внутри обработчика событий первого рендера всегда равно `0`, независимо от того, сколько раз вы вызываете `setNumber(1)`:

```jsx
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

Но здесь есть еще один фактор. React ждет, пока весь код в обработчиках событий не будет выполнен, прежде чем обрабатывать обновления вашего состояния. Вот почему повторная визуализация происходит только после всех этих вызовов `setNumber()`.

Это может напомнить вам официанта, принимающего заказ в ресторане. Официант не бежит на кухню при упоминании вашего первого блюда! Вместо этого он позволяет вам закончить свой заказ, позволяет вам вносить в него изменения и даже принимать заказы от других людей за столом.

![image](<../../images/2.5.1. Queueing a Series of State Updates.png>)

Это позволяет вам обновлять несколько переменных состояния — даже из нескольких компонентов — не вызывая слишком много повторных рендеров. Но это также означает, что пользовательский интерфейс не будет обновлен до тех пор, пока не завершится ваш обработчик событий и любой код в нем. Такое поведение, также известное как пакетирование, заставляет ваше приложение React работать намного быстрее. Это также позволяет избежать запутанных «полузаконченных» рендеров, где обновлены только некоторые переменные.

React не выполняет пакетирование по нескольким преднамеренным событиям, таким как щелчки — каждый щелчок обрабатывается отдельно. Будьте уверены, что React выполняет пакетирование только тогда, когда это в целом безопасно. Это гарантирует, что, например, если первое нажатие кнопки отключает форму, второе нажатие не отправит ее снова.

## [Обновление одного и того же состояния несколько раз перед следующим рендерингом](#)
