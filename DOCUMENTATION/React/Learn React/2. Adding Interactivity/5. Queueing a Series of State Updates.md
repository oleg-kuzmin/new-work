# [Постановка в очередь серии обновлений состояния](../../index.md)

- [Обзор](#обзор)
- [Резюме](#резюме)
- [Следующие шаги](#следующие-шаги)

## [Обзор](#)

**Установка переменной состояния поставит в очередь другой рендер. Но иногда вам может понадобиться выполнить несколько операций со значением перед постановкой в ​​очередь следующего рендера. Для этого полезно понять, как React пакетирует обновления состояния.**

### Ты выучишь

- Что такое «batching (пакетирование)» и как React использует его для обработки множественных обновлений состояния
- Как применить несколько обновлений к одной и той же переменной состояния подряд

## [React обновляет состояние пакетами](#)

Можно было бы ожидать, что нажатие кнопки «+3» увеличит счетчик в три раза, поскольку он вызывает `setNumber(number + 1)` три раза:

```jsx
// App.js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}>
        +3
      </button>
    </>
  );
}
```

Однако, как вы, возможно, помните из предыдущего раздела, [значения состояний каждого рендера фиксированы](https://react.dev/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time), поэтому значение `number` внутри обработчика событий первого рендера всегда равно `0`, независимо от того, сколько раз вы вызываете `setNumber(1)`:

```jsx
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

Но здесь есть еще один фактор. React ждет, пока весь код в обработчиках событий не будет выполнен, прежде чем обрабатывать обновления вашего состояния. Вот почему повторная визуализация происходит только после всех этих вызовов `setNumber()`.

Это может напомнить вам официанта, принимающего заказ в ресторане. Официант не бежит на кухню при упоминании вашего первого блюда! Вместо этого он позволяет вам закончить свой заказ, позволяет вам вносить в него изменения и даже принимать заказы от других людей за столом.

Это позволяет вам обновлять несколько переменных состояния — даже из нескольких компонентов — не вызывая слишком много повторных рендеров. Но это также означает, что пользовательский интерфейс не будет обновлен до тех пор, пока не завершится ваш обработчик событий и любой код в нем. Такое поведение, также известное как пакетирование, заставляет ваше приложение React работать намного быстрее. Это также позволяет избежать запутанных «полузаконченных» рендеров, где обновлены только некоторые переменные.

React не выполняет пакетирование по нескольким преднамеренным событиям, таким как щелчки — каждый щелчок обрабатывается отдельно. Будьте уверены, что React выполняет пакетирование только тогда, когда это в целом безопасно. Это гарантирует, что, например, если первое нажатие кнопки отключает форму, второе нажатие не отправит ее снова.

## [Обновление одного и того же состояния несколько раз перед следующим рендерингом](#)

Это необычный вариант использования, но если вы хотите обновить одну и ту же переменную состояния несколько раз перед следующим рендерингом, вместо передачи следующего значения состояния, например `setNumber(number 1)`, вы можете передать функцию, которая вычисляет следующее состояние на основе предыдущего в очереди, например `setNumber(n => n + 1)`. Это способ сказать React «сделать что-то со значением состояния» вместо того, чтобы просто заменить его.

Попробуйте увеличить счетчик сейчас:

```jsx
// App.js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(n => n + 1);
          setNumber(n => n + 1);
          setNumber(n => n + 1);
        }}>
        +3
      </button>
    </>
  );
}
```

Здесь `n => n + 1` называется функцией обновления. Когда вы передаете ее в сеттер состояния:

1. React ставит эту функцию в очередь на обработку после того, как будет выполнен весь остальной код в обработчике событий.
2. Во время следующего рендеринга React проходит по очереди и выдает вам окончательное обновленное состояние.

```jsx
setNumber(n => n + 1);
setNumber(n => n + 1);
setNumber(n => n + 1);
```

Вот как React работает с этими строками кода при выполнении обработчика событий:

1. `setNumber(n => n + 1)`: `n => n + 1` это функция. React добавляет ее в очередь.
2. `setNumber(n => n + 1)`: `n => n + 1` это функция. React добавляет ее в очередь.
3. `setNumber(n => n + 1)`: `n => n + 1` это функция. React добавляет ее в очередь.

Когда вы вызываете `useState` во время следующего рендеринга, React проходит по очереди. Предыдущее состояние `number` было `0`, поэтому React передает его первой функции обновления в качестве аргумента `n`. Затем React берет возвращаемое значение вашей предыдущей функции обновления и передает его следующей функции обновления в качестве `n` и так далее:

| обновление в очереди |  n  | возвращается |
| :------------------- | :-: | :----------- |
| n => n + 1           |  0  | 0 + 1 = 1    |
| n => n + 1           |  1  | 1 + 1 = 2    |
| n => n + 1           |  2  | 2 + 1 = 3    |

React сохраняет `3` как конечный результат и возвращает его из `useState`.

Вот почему нажатие «+3» в приведенном выше примере корректно увеличивает значение на 3.

### [Что произойдет, если вы обновите состояние после его замены?](#)
