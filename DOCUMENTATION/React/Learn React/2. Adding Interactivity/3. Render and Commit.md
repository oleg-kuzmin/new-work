# [Рендер и фиксация](../../index.md)

- [Обзор](#обзор)
- [Резюме](#резюме)
- [Следующие шаги](#следующие-шаги)

## [Обзор](#)

**Прежде чем ваши компоненты будут отображены на экране, их должен отрисовать React. Понимание шагов этого процесса поможет вам задуматься о том, как выполняется ваш код, и объяснить его поведение.**

### Ты выучишь

- Что означает рендеринг в React
- Когда и почему React рендерит компонент
- Шаги, необходимые для отображения компонента на экране
- Почему рендеринг не всегда приводит к обновлению DOM

Представьте, что ваши компоненты — это повара на кухне, которые готовят вкусные блюда из ингредиентов. В этом сценарии React — это официант, который принимает запросы от клиентов и приносит им их заказы. Этот процесс запроса и обслуживания пользовательского интерфейса состоит из трех этапов:

1. **Triggering** - запуск рендеринга (доставка заказа гостя на кухню)
2. **Rendering** - рендеринг компонента (приготовление заказа на кухне)
3. **Committing** - принятие решения о размещении заказа на столе.

## [Шаг 1: Запуск рендеринга](#)

Существует две причины для рендеринга компонента:

1. Это начальный рендеринг компонента.
2. Состояние компонента (или одного из его предков) было обновлено.

### [Начальный рендер](#)

Когда ваше приложение запускается, вам нужно запустить начальный рендеринг. Фреймворки и песочницы иногда скрывают этот код, но это делается путем вызова [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) с целевым узлом DOM, а затем вызова его метода рендеринга с вашим компонентом:

```jsx
// index.js
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<Image />);
```

```jsx
// Image.js
export default function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

Попробуйте закомментировать вызов `root.render()` и увидите, как компонент исчезнет!

### [Повторный рендер при обновлении состояния](#)

После того, как компонент изначально отрендерен, вы можете запустить дальнейшие рендеры, обновив его состояние с помощью [функции set](https://react.dev/reference/react/useState#setstate). Обновление состояния вашего компонента автоматически ставит рендер в очередь. (Вы можете представить это как гостя ресторана, заказывающего чай, десерт и все виды вещей после того, как он сделал свой первый заказ, в зависимости от состояния его жажды или голода.)

## [Шаг 2: React рендерит ваши компоненты](#)

После того, как вы запускаете рендеринг, React вызывает ваши компоненты, чтобы выяснить, что отображать на экране. «Рендеринг» — это вызов React ваших компонентов.

- При первоначальном рендеринге React вызовет корневой компонент.
- Для последующих рендеров React будет вызывать компонент функции, обновление состояния которого инициировало рендеринг.

Этот процесс рекурсивен: если обновленный компонент возвращает какой-либо другой компонент, React отобразит этот компонент следующим, а если этот компонент также возвращает что-то, он отобразит этот компонент следующим и т.д. Процесс будет продолжаться до тех пор, пока не останется больше вложенных компонентов, и React не будет точно знать, что должно отображаться на экране.

В следующем примере React вызовет `Gallery()` и `Image()` несколько раз:

```jsx
// Gallery.js
export default function Gallery() {
  return (
    <section>
      <h1>Inspiring Sculptures</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

```jsx
// index.js
import Gallery from './Gallery.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<Gallery />);
```

- Во время первоначального рендеринга React [создаст узлы DOM](https://developer.mozilla.org/docs/Web/API/Document/createElement) для тегов `<section>`, `<h1>` и трех `<img>`.
- Во время повторного рендеринга React вычислит, какие из его свойств, если таковые имеются, изменились с момента предыдущего рендеринга. Он ничего не сделает с этой информацией до следующего шага, фазы фиксации.

### Внимание!

> Рендеринг всегда должен представлять собой чистые вычисления:

> - Те же входы, тот же выход. При тех же входных данных компонент должен всегда возвращать тот же JSX. (Когда кто-то заказывает салат с помидорами, он не должен получать салат с луком!)
> - Он занимается своими делами. Он не должен изменять никакие объекты или переменные, которые существовали до рендеринга. (Один заказ не должен изменять чей-либо другой заказ.)

> В противном случае вы можете столкнуться с запутанными ошибками и непредсказуемым поведением по мере усложнения вашей кодовой базы. При разработке в «Strict Mode» React дважды вызывает функцию каждого компонента, что может помочь обнаружить ошибки, вызванные нечистыми функциями.

### Оптимизация производительности

> Поведение по умолчанию, при котором отображаются все компоненты, вложенные в обновленный компонент, не является оптимальным для производительности, если обновленный компонент находится очень высоко в дереве. Если вы столкнулись с проблемой производительности, есть несколько дополнительных способов ее решения, описанных в разделе [Производительность](https://reactjs.org/docs/optimizing-performance.html). Не оптимизируйте преждевременно!

## [Шаг 3: React фиксирует изменения в DOM](#)
