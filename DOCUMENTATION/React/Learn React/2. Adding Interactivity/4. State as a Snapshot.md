# [Состояние как моментальный снимок](../../index.md)

- [Обзор](#обзор)
- [Резюме](#резюме)
- [Следующие шаги](#следующие-шаги)

## [Обзор](#)

**Переменные состояния могут выглядеть как обычные переменные JavaScript, которые вы можете читать и записывать. Однако состояние ведет себя скорее как снимок. Установка состояния не изменяет переменную состояния, которая у вас уже есть, а вместо этого запускает повторный рендеринг.**

### Ты выучишь

- Как установка состояния запускает повторный рендеринг
- Когда и как обновляется состояние
- Почему состояние не обновляется сразу после его изменения
- Как обработчики событий получают доступ к «снимку» состояния

## [Изменение состояния запускает триггер рендеринга]

Вы можете думать о своем пользовательском интерфейсе как об изменении непосредственно в ответ на пользовательское событие, например, на клик. В React это работает немного иначе, чем в этой ментальной модели. На предыдущей странице вы видели, что [установка состояния запрашивает повторный рендеринг](https://react.dev/learn/render-and-commit#step-1-trigger-a-render) из React. Это означает, что для того, чтобы интерфейс отреагировал на событие, вам нужно обновить состояние.

В этом примере, когда вы нажимаете «send», `setIsSent(true)` сообщает React о необходимости повторного рендера пользовательского интерфейса:

```jsx
// App.js
import { useState } from 'react';

export default function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Hi!');
  if (isSent) {
    return <h1>Your message is on its way!</h1>;
  }
  return (
    <form
      onSubmit={e => {
        e.preventDefault();
        setIsSent(true);
        sendMessage(message);
      }}>
      <textarea placeholder="Message" value={message} onChange={e => setMessage(e.target.value)} />
      <button type="submit">Send</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}
```

Вот что происходит, когда вы нажимаете кнопку:

1. Выполняется обработчик событий `onSubmit`.
2. `setIsSent(true)` устанавливает для `isSent` значение `true` и ставит в очередь новый рендеринг.
3. React перерисовывает компонент в соответствии с новым значением `isSent`.

Давайте подробнее рассмотрим связь между состоянием и рендерингом.

## [Рендеринг делает моментальный снимок во времени](#)

[«Рендеринг»](https://react.dev/learn/render-and-commit#step-2-react-renders-your-components) означает, что React вызывает ваш компонент, который является функцией. JSX, который вы возвращаете из этой функции, подобен моментальному снимку пользовательского интерфейса во времени. Его props, обработчики событий и локальные переменные были рассчитаны с использованием его состояния во время рендеринга.

В отличие от фотографии или кадра фильма, возвращаемый вами «снимок» пользовательского интерфейса является интерактивным. Он включает логику, например обработчики событий, которые определяют, что происходит в ответ на ввод. React обновляет экран в соответствии с этим снимком и подключает обработчики событий. В результате нажатие кнопки вызовет обработчик щелчков из вашего JSX.

Когда React повторно рендерит компонент:

1. React снова вызывает вашу функцию.
2. Ваша функция возвращает новый снимок JSX.
3. Затем React обновляет экран в соответствии со снимком, который вернула ваша функция.

Как память компонента, состояние не похоже на обычную переменную, которая исчезает после return из вашей функции. Состояние на самом деле «живет» в самом React — как на полке! — вне вашей функции. Когда React вызывает ваш компонент, он дает вам снимок состояния для этого конкретного рендера. Ваш компонент возвращает снимок пользовательского интерфейса со свежим набором всех свойств и обработчиков событий в своем JSX, вычисленные с использованием значений состояния из этого рендера!

Вот небольшой эксперимент, чтобы показать вам, как это работает. В этом примере вы могли бы ожидать, что нажатие кнопки «+3» увеличит счетчик три раза, потому что он вызывает `setNumber(number + 1)` три раза.

Посмотрите, что произойдет, если вы нажмете кнопку «+3»:

```jsx
// App.js
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}>
        +3
      </button>
    </>
  );
}
```

Обратите внимание, что число увеличивается только один раз за один клик!

Установка состояния изменяет его только для следующего рендера. Во время первого рендера `number` был `0`. Вот почему в обработчике `onClick` этого рендера значение `number` по-прежнему равно `0` даже после вызова `setNumber(number + 1)`:

```jsx
<button
  onClick={() => {
    setNumber(number + 1);
    setNumber(number + 1);
    setNumber(number + 1);
  }}>
  +3
</button>
```

Вот что обработчик нажатия этой кнопки сообщает React сделать:

- `setNumber(number + 1)`: `number` равно `0`, поэтому `setNumber(0 + 1)`
  - React готовится изменить `number` на `1` при следующем рендеринге.
- `setNumber(number + 1)`: `number` равно `0`, поэтому `setNumber(0 + 1)`
  - React готовится изменить `number` на `1` при следующем рендеринге.
- `setNumber(number + 1)`: `number` равно `0`, поэтому `setNumber(0 + 1)`
  - React готовится изменить `number` на `1` при следующем рендеринге.

Несмотря на то, что вы вызвали `setNumber(number 1)` три раза, в этом обработчике событий рендеринга `number` всегда равен `0`, поэтому вы трижды устанавливаете состояние на `1`. Вот почему после завершения вашего обработчика событий React повторно рендерит компонент с номером, равным `1`, а не `3`.

Вы также можете представить это мысленно заменив переменные состояния их значениями в вашем коде. Поскольку переменная состояния `number` равна `0` для этого рендера, ее обработчик событий выглядит следующим образом:

```jsx
<button
  onClick={() => {
    setNumber(0 + 1);
    setNumber(0 + 1);
    setNumber(0 + 1);
  }}>
  +3
</button>
```

Для следующего рендера `number` равно `1`, поэтому обработчик кликов этого рендера выглядит следующим образом:

```jsx
<button
  onClick={() => {
    setNumber(1 + 1);
    setNumber(1 + 1);
    setNumber(1 + 1);
  }}>
  +3
</button>
```

Вот почему повторное нажатие кнопки установит счетчик на `2`, затем на `3` при следующем нажатии и так далее.

## [Состояние с течением времени](#)
