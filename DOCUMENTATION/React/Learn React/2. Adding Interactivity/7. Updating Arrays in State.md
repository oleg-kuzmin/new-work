# [Обновление массивов в состоянии](../../index.md)

- [Обзор](#обзор)
- [Резюме](#резюме)
- [Следующие шаги](#следующие-шаги)

## [Обзор](#)

**Массивы изменяемы в JavaScript, но вы должны обращаться с ними как с неизменяемыми, когда сохраняете их в состоянии. Как и в случае с объектами, когда вы хотите обновить массив, хранящийся в состоянии, вам нужно создать новый (или сделать копию существующего), а затем установить состояние для использования нового массива.**

### Ты выучишь

- Как добавлять, удалять или изменять элементы в массиве в состоянии React
- Как обновить объект внутри массива
- Как сделать копирование массива менее повторяющимся с помощью Immer

## [Обновление массивов без мутации](#)

В JavaScript массивы — это просто еще один вид объектов. [Как и в случае с объектами](https://react.dev/learn/updating-objects-in-state), вы должны рассматривать массивы в состоянии React как доступные только для чтения. Это означает, что вы не должны переназначать элементы внутри массива, например, `arr[0] = 'bird'`, и вы также не должны использовать методы, которые изменяют массив, например, `push()` и `pop()`.

Вместо этого, каждый раз, когда вы хотите обновить массив, вы хотите передать новый массив в функцию установки состояния. Чтобы сделать это, вы можете создать новый массив из исходного массива в вашем состоянии, вызвав его немутирующие методы, такие как `filter()` и `map()`. Затем вы можете установить свое состояние на полученный новый массив.

Вот справочная таблица общих операций с массивами. При работе с массивами внутри состояния React вам нужно будет избегать методов в левом столбце и вместо этого предпочесть методы в правом столбце:

| операция   | избегать (мутирует массив)            | использовать (возвращает новый массив)           |
| :--------- | :------------------------------------ | :----------------------------------------------- |
| добавление | `push`, `unshift`                     | `concat, [...arr]` спред синтаксис ([пример](#)) |
| удаление   | `pop`, `shift`, `splice`              | `filter`, `slice` ([пример](#))                  |
| замена     | `splice`, `arr[i] = ...` присваивание | `map` ([пример](#))                              |
| сортировка | `reverse`, `sort`                     | сначала скопируйте массив ([пример](#))          |

В качестве альтернативы вы можете [использовать Immer](https://react.dev/learn/updating-arrays-in-state#write-concise-update-logic-with-immer), который позволяет использовать методы из обоих столбцов.

### Внимание!

К сожалению, [`slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) и [`splice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) называются одинаково, но на самом деле они очень разные:

- `slice` позволяет копировать массив или его часть.
- `splice` мутирует массив (вставляет или удаляет элементы).

В React вы будете использовать `slice` (без `p`!) гораздо чаще, потому что вы не хотите мутировать объекты или массивы в состоянии. [Обновление объектов](https://react.dev/learn/updating-objects-in-state) объясняет, что такое мутация и почему она не рекомендуется для состояния.

### [Добавление в массив](#)

`push()` мутирует массив, что вам не нужно:

```jsx
// App.js
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <input value={name} onChange={e => setName(e.target.value)} />
      <button
        onClick={() => {
          artists.push({
            id: nextId++,
            name: name,
          });
        }}>
        Add
      </button>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

Вместо этого создайте новый массив, содержащий существующие элементы и новый элемент в конце. Есть несколько способов сделать это, но самый простой — использовать `...` [спред-синтаксис массива](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_array_literals):

```jsx
setArtists(
  // заменим состояние
  [
    // новым массивом
    ...artists, // который содержит все старые элементы
    { id: nextId++, name: name }, // и один новый элемент в конце
  ]
);
```

Теперь всё работает правильно:

```jsx
// App.js
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <input value={name} onChange={e => setName(e.target.value)} />
      <button
        onClick={() => {
          setArtists([...artists, { id: nextId++, name: name }]);
        }}>
        Add
      </button>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

Спред-синтаксис массива также позволяет добавлять элемент, помещая его перед исходным `...artists`:

```jsx
// App.js
setArtists([
  { id: nextId++, name: name },
  ...artists, // старые элементы положим в конец
]);
```

Таким образом, спред-синтаксис может выполнять работу как `push()`, добавляя в конец массива, так и `unshift()`, добавляя в начало массива. Попробуйте сами.

### [Удаление из массива](#)
