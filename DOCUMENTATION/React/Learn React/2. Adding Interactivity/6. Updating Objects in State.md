# [Обновление объектов в состоянии](../../index.md)

- [Обзор](#обзор)
- [Резюме](#резюме)
- [Следующие шаги](#следующие-шаги)

## [Обзор](#)

**Состояние может содержать любое значение JavaScript, включая объекты. Но вам не следует напрямую изменять объекты, которые вы храните в состоянии React. Вместо этого, когда вы хотите обновить объект, вам нужно создать новый (или сделать копию существующего), а затем настроить состояние на использование этой копии.**

### Ты выучишь

- Как правильно обновить объект в состоянии React
- Как обновить вложенный объект, не изменяя его
- Что такое иммутабельность и как ее не нарушить
- Как сделать копирование объектов менее повторяющимся с помощью Immer

## [Что такое мутация?](#)

В состоянии можно хранить любое значение JavaScript.

```jsx
const [x, setX] = useState(0);
```

До сих пор вы работали с числами, строками и булевыми значениями. Эти типы значений JavaScript являются «иммутабельными», то есть неизменяемыми или «доступными только для чтения». Вы можете запустить повторный рендеринг для замены значения:

```jsx
setX(5);
```

Состояние `x` изменилось с `0` на `5`, но само число `0` не изменилось. В JavaScript невозможно вносить какие-либо изменения во встроенные примитивные значения, такие как числа, строки и логические значения.

Теперь рассмотрим объект в состоянии:

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });
```

Технически возможно изменить содержимое самого объекта. Это называется мутацией:

```jsx
position.x = 5;
```

Однако, хотя объекты в состоянии React технически изменяемы, вы должны обращаться с ними так, как будто они неизменяемы — как числа, логические значения и строки. Вместо того, чтобы изменять их, вы всегда должны их заменять.

## [Рассматривать состояние как доступное только для чтения](#)

Другими словами, вы должны рассматривать любой объект JavaScript, который вы переводите в состояние «только для чтения».

Этот пример удерживает объект в состоянии, представляющем текущую позицию указателя. Красная точка должна перемещаться, когда вы касаетесь или перемещаете курсор по области предварительного просмотра. Но точка остается в исходном положении:

```jsx
// App.js
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={e => {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'red',
          borderRadius: '50%',
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

Проблема в этом фрагменте кода.

```jsx
onPointerMove={e => {
  position.x = e.clientX;
  position.y = e.clientY;
}}
```

Этот код изменяет объект, назначенный на `position` из [предыдущего рендера](https://react.dev/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time). Но без использования функции установки состояния React не имеет ни малейшего представления о том, что объект изменился. Поэтому React ничего не делает в ответ. Это как пытаться изменить заказ после того, как вы уже съели еду. Хотя изменение состояния может работать в некоторых случаях, мы не рекомендуем его. Вы должны рассматривать значение состояния, к которому у вас есть доступ в рендере, как доступное только для чтения.

Чтобы в этом случае действительно запустить повторный рендеринг, создайте новый объект и передайте его функции установки состояния:

```jsx
onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
```

С помощью `setPosition` вы сообщаете React:

- Заменить `position` этим новым объектом
- И снова отрендерить этот компонент

Обратите внимание, как красная точка теперь следует за указателем, когда вы касаетесь или наводите курсор на область предварительного просмотра:

```jsx
// App.js
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={e => {
        setPosition({
          x: e.clientX,
          y: e.clientY,
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'red',
          borderRadius: '50%',
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

### Локальная мутация в порядке
