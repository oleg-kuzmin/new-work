# [Почему Vite](../index.md)

- [Проблемы](#проблемы)
- [Медленный запуск сервера](#медленный-запуск-сервера)
- [Медленные обновления](#медленные-обновления)
- [Зачем использовать Bundle для Production](#зачем-использовать-bundle-для-production)
- [Почему не Bundle с esbuild?](#почему-не-bundle-с-esbuild)
- [Чем Vite отличается от X?](#чем-vite-отличается-от-x)

## [Проблемы](#почему-vite)

До того, как модули ES стали доступны в браузерах, у разработчиков не было собственного механизма для создания JavaScript в модульном стиле. Вот почему мы все знакомы с концепцией `bundling`: использование инструментов, которые сканируют, обрабатывают и объединяют наши исходные модули в файлы, которые могут запускаться в браузере.

Со временем мы увидели такие инструменты, как [Webpack](https://webpack.js.org/), [Rollup](https://rollupjs.org/) и [Parcel](https://parceljs.org/), которые значительно улучшили опыт разработки для фронтенд-разработчиков.

Однако по мере того, как мы создаем все более амбициозные приложения, объем JavaScript, с которым мы имеем дело, также резко увеличивается. Нередко крупномасштабные проекты содержат тысячи модулей. Мы начинаем сталкиваться с узким местом производительности для инструментов на основе JavaScript: часто может потребоваться неоправданно долгое ожидание (иногда до нескольких минут!), чтобы развернуть сервер разработки, и даже с `Hot Module Replacement (HMR)` редактирование файлов может занять несколько секунд, чтобы отразиться в браузере. Медленный цикл обратной связи может сильно повлиять на производительность и удовлетворенность разработчиков.

Vite стремится решить эти проблемы, используя новые достижения в экосистеме: доступность собственных ES-модулей в браузере и появление инструментов JavaScript, написанных на языках, компилируемых в нативные.

## [Медленный запуск сервера](#почему-vite)

При холодном запуске сервера разработки установка сборки на основе бандлера должна тщательно просканировать и собрать все приложение, прежде чем его можно будет запустить.

Vite улучшает время запуска сервера разработки, сначала разделяя модули приложения на две категории: зависимости и исходный код.

- Зависимости в основном представляют собой простой JavaScript, который нечасто меняется в процессе разработки. Некоторые большие зависимости (например, библиотеки компонентов с сотнями модулей) также довольно дороги в обработке. Зависимости также могут поставляться в различных форматах модулей (например, ESM или CommonJS).

Vite [предварительно объединяет зависимости](https://vitejs.dev/guide/dep-pre-bundling) с помощью [esbuild](https://esbuild.github.io/). esbuild написан на Go и предварительно объединяет зависимости в 10–100 раз быстрее, чем сборщики на основе JavaScript.

- Исходный код часто содержит не простой JavaScript, который требует преобразования (например, компоненты JSX, CSS или Vue/Svelte) и будет очень часто редактироваться. Кроме того, не обязательно загружать весь исходный код одновременно (например, при разделении кода на основе маршрутов).

Vite обслуживает исходный код через [нативные ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). По сути, это позволяет браузеру взять на себя часть работы сборщика: Vite нужно только преобразовывать и обслуживать исходный код по требованию, когда браузер его запрашивает. Код, лежащий в основе условных динамических импортов, обрабатывается только в том случае, если он фактически используется на текущем экране.

## [Медленные обновления](#почему-vite)

Когда файл редактируется в настройке сборки на основе бандлера, пересобирать весь пакет неэффективно по очевидной причине: скорость обновления будет линейно ухудшаться с размером приложения.

В некоторых сборщиках сервер разработки запускает сборку в памяти, так что ему нужно только сделать недействительной часть своего графа модулей при изменении файла, но ему все равно нужно перестроить весь пакет и перезагрузить веб-страницу. Перестройка пакета может быть затратной, а перезагрузка страницы стирает текущее состояние приложения. Вот почему некоторые сборщики поддерживают горячую замену модулей (HMR): позволяя модулю «горячо заменять» себя, не затрагивая остальную часть страницы. Это значительно улучшает DX - однако на практике мы обнаружили, что даже скорость обновления HMR значительно ухудшается по мере роста размера приложения.

В Vite HMR выполняется поверх собственного ESM. Когда файл редактируется, Vite нужно только точно аннулировать цепочку между редактируемым модулем и его ближайшей границей HMR (чаще всего только сам модуль), что делает обновления HMR постоянно быстрыми независимо от размера вашего приложения.

Vite также использует заголовки HTTP для ускорения полной перезагрузки страницы (опять же, позвольте браузеру сделать больше работы за нас): запросы к исходному коду модуля обусловливаются с помощью `304 Not Modified`, а запросы к зависимым модулям строго кэшируются с помощью `Cache-Control: max-age=31536000,immutable`, чтобы они не попадали на сервер снова после кэширования.

Как только вы почувствуете, насколько быстр Vite, мы очень сомневаемся, что вы снова захотите мириться с комплексной разработкой.

## [Зачем использовать Bundle для Production](#почему-vite)

Несмотря на то, что нативный ESM теперь широко поддерживается, отправка неупакованного ESM в продакшн все еще неэффективна (даже с HTTP/2) из-за дополнительных сетевых циклов, вызванных вложенными импортами. Чтобы получить оптимальную производительность загрузки в производстве, все еще лучше упаковать ваш код с tree-shaking, lazy-loading и общим chunk splitting (для лучшего кэширования).

Обеспечить оптимальную производительность и согласованность поведения между сервером разработки и производственной сборкой непросто. Вот почему Vite поставляется с предварительно настроенной [командой сборки](https://vitejs.dev/guide/build), которая сразу же включает в себя множество [оптимизаций производительности](https://vitejs.dev/guide/features#build-optimizations).

## [Почему не Bundle с esbuild?](#почему-vite)

Текущий API плагина Vite несовместим с использованием `esbuild` в качестве сборщика. Несмотря на то, что `esbuild` быстрее, принятие Vite гибкого API плагина Rollup и инфраструктуры в значительной степени способствовало его успеху в экосистеме. На данный момент мы считаем, что Rollup предлагает лучший компромисс производительности и гибкости.

Rollup также работает над повышением производительности, [переключив свой парсер на SWC в v4](https://github.com/rollup/rollup/pull/5073). И ведутся постоянные усилия по созданию Rust-порта Rollup под названием Rolldown. Как только Rolldown будет готов, он может заменить и Rollup, и esbuild в Vite, значительно улучшив производительность сборки и устранив несоответствия между разработкой и сборкой. Вы можете посмотреть [основной доклад Evan You на ViteConf 2023](https://youtu.be/hrdwQHoAp0M) для получения более подробной информации.

## [Чем Vite отличается от X?](#почему-vite)

Вы можете просмотреть раздел [Comparisons (Сравнения)](https://vitejs.dev/guide/comparisons), чтобы узнать больше о том, чем Vite отличается от других подобных инструментов.
