# [TypeScript для программистов JavaScript](../index.md)

- [Типы по логике](#типы-по-логике)
- [Определение типов](#определение-типов)
- [Составление типов](#составление-типов)
  - [Unions](#unions)
  - [Generics](#generics)
- [Система структурных типов](#система-структурных-типов)
- [Следующие шаги](#следующие-шаги)

TypeScript находится в необычном отношении к JavaScript. TypeScript предлагает все функции JavaScript и дополнительный уровень поверх них: систему типов TypeScript.

Например, JavaScript предоставляет примитивы языка, такие как строка и число, но не проверяет, последовательно ли вы их присвоили. TypeScript делает это.

Это означает, что ваш существующий рабочий код JavaScript также является кодом TypeScript. Основное преимущество TypeScript заключается в том, что он может выявить неожиданное поведение вашего кода, снижая вероятность ошибок.

В этом руководстве представлен краткий обзор TypeScript с упором на его систему типов.

## [Типы по логике](#typescript-для-программистов-javascript)

TypeScript знает язык JavaScript и во многих случаях генерирует типы за вас. Например, при создании переменной и присвоении ей определенного значения TypeScript будет использовать это значение в качестве типа.

```ts
let helloWorld = 'Hello World';

// происходит под капотом
let helloWorld: string;
```

Понимая, как работает JavaScript, TypeScript может построить систему типов, которая принимает код JavaScript, но имеет типы. Это предлагает систему типов без необходимости добавлять дополнительные символы, чтобы сделать типы явными в вашем коде. Вот как TypeScript знает, что `helloWorld` — это `string` в приведенном выше примере.

Возможно, вы написали JavaScript в Visual Studio Code и использовали автодополнение в редакторе. Visual Studio Code использует TypeScript, чтобы упростить работу с JavaScript.

## [Определение типов](#typescript-для-программистов-javascript)

Вы можете использовать широкий спектр паттернов проектирования в JavaScript. Однако некоторые паттерны проектирования затрудняют автоматическое выведение типов (например, паттерны, использующие динамическое программирование). Чтобы охватить эти случаи, TypeScript поддерживает расширение языка JavaScript, которое предлагает вам места, где вы можете указать TypeScript, какими должны быть типы.

Например, чтобы создать объект с выведенным типом, который включает `name: string` и `id: number`, вы можете написать:

```ts
const user = {
  name: 'Hayes',
  id: 0,
};
```

Вы можете явно описать форму этого объекта, используя объявление `interface`:

```ts
interface User {
  name: string;
  id: number;
}
```

Затем вы можете объявить, что объект JavaScript соответствует форме вашего нового `interface`, используя синтаксис типа `: TypeName` после объявления переменной:

```ts
const user: User = {
  name: 'Hayes',
  id: 0,
};
```

Если вы предоставите объект, который не соответствует предоставленному вами интерфейсу, TypeScript предупредит вас:

```ts
interface User {
  name: string;
  id: number;
}

const user: User = {
  username: 'Hayes',
  // Ошибка! Объектный литерал может использовать только известные свойства. "username" не существует в типе "User".
  id: 0,
};
```

Поскольку JavaScript поддерживает классы и объектно-ориентированное программирование, TypeScript тоже. Вы можете использовать объявление интерфейса с классами:

```ts
interface User {
  name: string;
  id: number;
}

class UserAccount {
  name: string;
  id: number;

  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
  }
}

const user: User = new UserAccount('Murphy', 1);
```

Вы можете использовать интерфейсы для аннотации параметров и возврата значений функциям:

```ts
function deleteUser(user: User) {
  // ...
}

function getAdminUser(): User {
  //...
}
```

В JavaScript уже доступен небольшой набор примитивных типов: `boolean`, `bigint`, `null`, `number`, `string`, `symbol` и `undefined`, которые можно использовать в интерфейсе. TypeScript расширяет этот список еще несколькими, такими как `any` (разрешить что угодно), `unknown` (гарантировать, что кто-то, использующий этот тип, объявляет, что это за тип), `never` (невозможно, чтобы этот тип мог произойти) и `void` (функция, которая возвращает `undefined` или не имеет возвращаемого значения).

Вы увидите, что существует два синтаксиса построения типов: `Interfaces` and `Types`. Вы должны предпочесть `interface`. Используйте `type`, когда вам нужны определенные функции.

## [Составление типов](#typescript-для-программистов-javascript)

С помощью TypeScript вы можете создавать сложные типы, комбинируя простые. Есть два популярных способа сделать это: с помощью `unions` и с помощью `generics`.

### [Unions](#typescript-для-программистов-javascript)

С помощью `union` вы можете объявить, что тип может быть одним из многих типов. Например, вы можете описать `boolean` тип как `true` или `false`:

```ts
type MyBool = true | false;
```

Примечание. Если вы наведете курсор на `MyBool` в редакторе, вы увидите, что он классифицируется как `boolean`. Это свойство системы структурных типов. Подробнее об этом ниже.

Популярным вариантом использования типов `union` является описание набора литералов `string` или `number`, которыми может быть значение:

```ts
type WindowStates = 'open' | 'closed' | 'minimized';
type LockStates = 'locked' | 'unlocked';
type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
```

`unions` также предоставляют способ обработки разных типов. Например, у вас может быть функция, принимающая `array` или `string`:

```ts
function getLength(obj: string | string[]) {
  return obj.length;
}
```

Чтобы узнать тип переменной, используйте `typeof`:

| Type      | Predicate                          |
| :-------- | :--------------------------------- |
| string    | `typeof s === "string"`            |
| number    | `typeof n === "number"`            |
| boolean   | `typeof b === "boolean"`           |
| undefined | `typeof undefined === "undefined"` |
| function  | `typeof s === "string"`            |
| array     | `typeof f === "function"`          |

Например, вы можете заставить функцию возвращать разные значения в зависимости от того, передана ли ей строка или массив:

```ts
function wrapInArray(obj: string | string[]) {
  if (typeof obj === 'string') {
    return [obj];
  }
  return obj;
}
```

### [Generics](#typescript-для-программистов-javascript)

`Generics` предоставляют переменные типов. Типичным примером является массив. Массив без дженериков может содержать что угодно. Массив с дженериками может описывать значения, содержащиеся в массиве.

```ts
type StringArray = Array<string>;
type NumberArray = Array<number>;
type ObjectWithNameArray = Array<{ name: string }>;
```

Вы можете объявить свои собственные типы, использующие дженерики:

```ts
interface Backpack<Type> {
  add: (obj: Type) => void;
  get: () => Type;
}

// Эта строка является ярлыком, сообщающим TypeScript о наличии
// константы под названием `backpack`, и не беспокоиться о том, откуда она взялась.
declare const backpack: Backpack<string>;

// Объект является строкой, поскольку мы объявили его выше как переменную часть Backpack.
const object = backpack.get();

// Поскольку переменная backpack представляет собой строку, вы не можете передать число в функцию add.
backpack.add(23);
// Ошибка! Аргумент типа "number" нельзя назначить параметру типа "string".
```

## [Система структурных типов](#typescript-для-программистов-javascript)

Один из основных принципов TypeScript заключается в том, что проверка типов фокусируется на форме значений. Иногда это называют «утиной типизацией» или «структурной типизацией».

В системе структурных типов, если два объекта имеют одинаковую форму, они считаются принадлежащими к одному и тому же типу.

```ts
interface Point {
  x: number;
  y: number;
}

function logPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}

const point = { x: 12, y: 26 };
logPoint(point); // logs "12, 26"
```

Переменная `point` никогда не объявляется как тип `Point`. Однако TypeScript сравнивает форму `point` с формой `Point` при проверке типа. Они имеют одинаковую форму, поэтому код проходит.

Для сопоставления формы требуется совпадение только подмножества полей объекта.

```ts
const point3 = { x: 12, y: 26, z: 89 };
logPoint(point3); // logs "12, 26"

const rect = { x: 33, y: 3, width: 30, height: 80 };
logPoint(rect); // logs "33, 3"

const color = { hex: '#187ABF' };
logPoint(color);

// Аргумент типа '{ hex: string; }' не присваивается параметру типа 'Point'.
// В типе '{ hex: string; }' отсутствует следующие свойства из типа - 'Point': x, y
```

Нет никакой разницы между тем, как классы и объекты соответствуют формам:

```ts
class VirtualPoint {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

const newVPoint = new VirtualPoint(13, 56);
logPoint(newVPoint); // logs "13, 56"
```

Если объект или класс имеет все необходимые свойства, TypeScript сообщит, что они совпадают, независимо от деталей реализации.

## [Следующие шаги](#typescript-для-программистов-javascript)

Это был краткий обзор синтаксиса и инструментов, используемых в повседневной работе TypeScript. Отсюда вы можете:

- Прочитать [Handbook от начала до конца](<../Handbook/1. The TypeScript Handbook.md>)
- Изучить примеры в [песочницах](https://www.typescriptlang.org/play#show-examples)
- Продолжение - [TS Tooling in 5 minutes](<./3. TS Tooling in 5 minutes.md>)
