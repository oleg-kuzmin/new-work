# [Сужение](../index.md)

- [Введение](#введение)
- [Typeof type guards](#typeof-type-guards)
- [Сужение истинности](#сужение-истинности)
- [Сужение равенства](#сужение-равенства)
- [Оператор in](#оператор-in)
- [Оператор instanceof](#оператор-instanceof)
- [Присваивание](#присваивание)
- [Анализ потока](#анализ-потока)
- [Использование type predicates](#использование-type-predicates)

## [Введение](#сужение)

Представьте, что у нас есть функция `PadLeft`.

```ts
function padLeft(padding: number | string, input: string): string {
  throw new Error('Not implemented yet!');
}
```

Если `padding` имеет тип `number`, он будет рассматриваться как количество пробелов, которые мы хотим добавить к `input`. Если `padding` имеет тип `string`, он должен просто добавить `padding` к `input`. Давайте попробуем реализовать логику, когда в `PadLeft` передается тип `number` для `padding`.

```ts
function padLeft(padding: number | string, input: string): string {
  return ' '.repeat(padding) + input;
  // Аргумент типа "string | number" нельзя назначить параметру типа "number".
  // Тип "string" не может быть назначен для типа "number".
}
```

Ой-ой, мы получаем ошибку в `padding`. TypeScript предупреждает нас, что мы передаем значение с типом `number | string` в функцию `repeat`, которая принимает только `number`, и это правильно. Другими словами, мы не проверяли явно, является ли `padding` типом `number`, и не обрабатываем случай, когда это тип `string`, поэтому давайте сделаем это.

```ts
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === 'number') {
    return ' '.repeat(padding) + input;
  }
  return padding + input;
}
```

Если это в основном выглядит как неинтересный код JavaScript, то в этом-то и суть. За исключением добавленных нами аннотаций, этот код TypeScript выглядит как JavaScript. Идея в том, что система типов TypeScript направлена ​​на то, чтобы максимально упростить написание типичного кода JavaScript, не выворачиваясь наизнанку ради обеспечения безопасности типов.

Хотя это может показаться не таким уж большим, на самом деле здесь происходит много всего под капотом. Подобно тому, как TypeScript анализирует значения во время выполнения с использованием статических типов, он накладывает анализ типов на конструкции потока управления во время выполнения JavaScript, такие как `if/else`, условные тернарные операторы, циклы, проверки истинности и т.д., которые могут влиять на эти типы.

---

В нашей проверке `if` TypeScript видит `typeof padding === "number"` и понимает это как особую форму кода, называемую `type guard`.

TypeScript отслеживает возможные пути выполнения, которые могут быть использованы нашими программами для анализа наиболее конкретного возможного типа значения в данной позиции.

Он рассматривает эти специальные проверки (называемые `type guards (защитники типа)`) и присвоения, а процесс уточнения типов до более конкретных типов, чем объявленные, называется `narrowing (сужение)`. Во многих редакторах мы можем наблюдать за изменениями этих типов, и мы даже сделаем это в наших примерах.

```ts
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === 'number') {
    return ' '.repeat(padding) + input;
    // (parameter) padding: number
  }
  return padding + input;
  // (parameter) padding: string
}
```

Существует несколько различных конструкций, которые TypeScript понимает для сужения.

## [Typeof type guards](#сужение)

Как мы видели, JavaScript поддерживает оператор `typeof`, который может предоставить очень простую информацию о типе значений, которые мы имеем во время выполнения. TypeScript ожидает, что это вернет определенный набор строк:

- `"string"`
- `"number"`
- `"bigint"`
- `"boolean"`
- `"symbol"`
- `"undefined"`
- `"object"`
- `"function"`

Как мы видели в случае с `padLeft`, этот оператор довольно часто встречается во многих библиотеках JavaScript, и TypeScript может понимать его, чтобы сузить типы в разных ветвях.

В TypeScript проверка значения, возвращаемого `typeof`, является type guard (защитником типа). Поскольку TypeScript кодирует, как `typeof` работает с различными значениями, он знает о некоторых особенностях JavaScript. Например, обратите внимание, что в приведенном выше списке `typeof` не возвращает строку `null`. Посмотрите следующий пример:

```ts
function printAll(strs: string | string[] | null) {
  if (typeof strs === 'object') {
    for (const s of strs) {
      // Ошибка: Возможно, "strs" имеет значение null.
      console.log(s);
    }
  } else if (typeof strs === 'string') {
    console.log(strs);
  } else {
    // ничего не делай
  }
}
```

В функции `printAll` мы пытаемся проверить, является ли `strs` объектом, чтобы увидеть, является ли он типом массива (сейчас самое время напомнить что массивы являются объектами в JavaScript). Но оказывается, что в JavaScript `typeof null` на самом деле является `"object"`! Это одна из тех досадных случайностей в истории.

Пользователи с достаточным опытом, возможно, не удивятся, но не все сталкивались с этим в JavaScript; к счастью, TypeScript сообщает нам, что `strs` была сужена до `string[] | null` вместо просто `string[]`.

Это может быть хорошим переходом к тому, что мы будем называть проверкой truthiness (истинности).

## [Сужение истинности](#сужение)

Возможно, «правдивость или истинность» — это не то слово, которое вы найдете в словаре, но вы наверняка услышите о нем в JavaScript.

В JavaScript мы можем использовать любое выражение в условных выражениях, `&&`, `||`, операторах `if`, логических отрицаниях (`!`) и многом другом. Например, операторы `if` не ожидают, что их условие всегда будет иметь тип `boolean`.

```ts
function getUsersOnlineMessage(numUsersOnline: number) {
  if (numUsersOnline) {
    return `There are ${numUsersOnline} online now!`;
  }
  return "Nobody's here. :(";
}
```

В JavaScript такие конструкции, как `if`, сначала преобразуют свои условия к логическим значениям `boolean`, чтобы они имели смысл, а затем выбирают их ветви в зависимости от того, является ли результат `true` или `false`. Такие значения, как

- `0`
- `NaN`
- `""` (пустая строка)
- `0n` (bigint версия нуля)
- `null`
- `undefined`

приводятся к `false`, а другие значения приводятся к `true`. Вы всегда можете преобразовать значения в логические `boolean`, пропустив их через функцию `Boolean` или используя более короткое двойное логическое отрицание (`!!`) (Последний вариант имеет преимущество, что TypeScript в результате выводит тип литерала `true`, а первый — выведет логический тип `boolean`).

```ts
// Оба они приводят к 'true'
Boolean('hello'); // type: boolean, value: true
!!'world'; // type: true, value: true
```

Такое поведение довольно популярно использовать, особенно для защиты от таких значений, как `null` или `undefined`. В качестве примера давайте попробуем использовать его для нашей функции `printAll`.

```ts
function printAll(strs: string | string[] | null) {
  if (strs && typeof strs === 'object') {
    for (const s of strs) {
      console.log(s);
    }
  } else if (typeof strs === 'string') {
    console.log(strs);
  }
}
```

Вы заметите, что мы избавились от вышеуказанной ошибки, проверив, является ли `strs` true. Это, по крайней мере, предохраняет нас от ужасных ошибок при запуске кода, например:

```bash
TypeError: null is not iterable # TypeError: null не является итерируемым
```

Однако имейте в виду, что проверка истинности примитивов часто может быть подвержена ошибкам. В качестве примера рассмотрим другую попытку написать `printAll`.

```ts
function printAll(strs: string | string[] | null) {
  // !!!!!!!!!!!!!!!!
  // Не делай этого!
  // Продолжайте читать
  // !!!!!!!!!!!!!!!!
  if (strs) {
    if (typeof strs === 'object') {
      for (const s of strs) {
        console.log(s);
      }
    } else if (typeof strs === 'string') {
      console.log(strs);
    }
  }
}
```

Мы обернули все тело функции проверкой истинности, но у этого есть небольшой недостаток: мы можем больше не правильно обрабатывать случай пустой строки.

TypeScript здесь нам совсем не вредит, но это поведение стоит отметить, если вы не так хорошо знакомы с JavaScript. TypeScript часто может помочь вам обнаружить ошибки на ранней стадии, но если вы решите ничего не делать со значением, то он может сделать лишь ограниченное количество действий. При желании вы можете убедиться, что справляетесь с подобными ситуациями с помощью linter.

Последнее слово о сужении истинности: булевые отрицания с помощью `!` отфильтровываются из ветвей с отрицаниями.

```ts
function multiplyAll(values: number[] | undefined, factor: number): number[] | undefined {
  if (!values) {
    return values;
  } else {
    return values.map(x => x * factor);
  }
}
```

## [Сужение равенства](#сужение)

TypeScript также использует операторы `switch` и проверки равенства, такие как `===,` `!==`, `==` и `!=`, для сужения типов. Например:

```ts
function example(x: string | number, y: string | boolean) {
  if (x === y) {
    // Теперь мы можем вызвать любой метод «string» для «x» или «y».
    x.toUpperCase(); // (method) String.toUpperCase(): string
    y.toLowerCase(); // (method) String.toLowerCase(): string
  } else {
    console.log(x); // (parameter) x: string | number
    console.log(y); // (parameter) y: string | boolean
  }
}
```

Когда мы проверили, что `x` и `y` оба равны в приведенном выше примере, TypeScript знал, что их типы также должны быть равны. Поскольку `string` — единственный общий тип, который могут принимать как `x`, так и `y`, TypeScript знает, что `x` и `y` должны быть `string` в первой ветви.

Проверка по определенным литеральным значениям (в отличие от переменных) также работает. В разделе о сужении истинности мы написали функцию `printAll`, которая была подвержена ошибкам, поскольку она случайно не обрабатывала пустые строки должным образом. Вместо этого мы могли бы сделать специальную проверку, чтобы заблокировать `null`, и TypeScript по-прежнему правильно удаляет `null` из типа `strs`.

```ts
function printAll(strs: string | string[] | null) {
  if (strs !== null) {
    if (typeof strs === 'object') {
      for (const s of strs) {
        console.log(s); // (parameter) strs: string[]
      }
    } else if (typeof strs === 'string') {
      console.log(strs); // (parameter) strs: string
    }
  }
}
```

Более свободные проверки равенства JavaScript с помощью `==` и `!=` также корректно сужаются. Если вы не знакомы, проверка того, что что-то `== null`, на самом деле не только проверяет, является ли это значением `null`, но и проверяет, является ли оно потенциально `undefined`. То же самое относится к `== undefined`: он проверяет, является ли значение либо `null`, либо `undefined`.

```ts
interface Container {
  value: number | null | undefined;
}

function multiplyValue(container: Container, factor: number) {
  // Удалите из типа значения «null» и «undefined».
  if (container.value != null) {
    console.log(container.value); // (property) Container.value: number
    container.value *= factor; // Теперь мы можем безопасно умножать «container.value».
  }
}
```

## [Оператор in](#сужение)

В JavaScript есть оператор, позволяющий определить, имеет ли объект или его цепочка прототипов свойство с именем: оператор `in`. TypeScript учитывает это как способ сузить потенциальные типы.

Например, с кодом: `"value" in x`. где `"value"` — строковый литерал, а `x` — тип `union`. Ветвь "true" сужает типы `x`, которые имеют либо необязательное, либо обязательное свойство `value`, а ветвь "false" сужает типы, которые имеют необязательное или отсутствующее свойство `value`.

```ts
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
  if ('swim' in animal) {
    return animal.swim();
  }

  return animal.fly();
}
```

Повторяем, опциональные необязательные свойства будут существовать в обоих ветках для сужения. Например, человек может и плавать, и летать (с подходящим снаряжением) и поэтому должен появляться в обоих ветках проверки `in`:

```ts
type Fish = { swim: () => void };
type Bird = { fly: () => void };
type Human = { swim?: () => void; fly?: () => void };

function move(animal: Fish | Bird | Human) {
  if ('swim' in animal) {
    animal; // (parameter) animal: Fish | Human
  } else {
    animal; // (parameter) animal: Bird | Human
  }
}
```

## [Оператор instanceof](#сужение)

В JavaScript есть оператор для проверки того, является ли значение `instance (экземпляром)` другого значения. Более конкретно, в JavaScript `x instanceof Foo` проверяет, содержит ли цепочка прототипов `x` прототип `Foo.prototype` . Хотя мы не будем здесь углубляться, и вы увидите больше этого, когда перейдем к классам, они все равно могут быть полезны для большинства значений, которые можно создать с помощью `new`. Как вы могли догадаться, `instanceof` также является защитником типа, и TypeScript сужает типы в ветках, защищенных `instanceof`.

```ts
function logValue(x: Date | string) {
  if (x instanceof Date) {
    console.log(x.toUTCString()); // (parameter) x: Date
  } else {
    console.log(x.toUpperCase()); // (parameter) x: string
  }
}
```

## [Присваивание](#сужение)

Как мы упоминали ранее, когда мы присваиваем значение какой-либо переменной, TypeScript просматривает правую часть присваивания и соответствующим образом сужает левую часть.

```ts
let x = Math.random() < 0.5 ? 10 : 'hello world!'; // let x: string | number

x = 1;
console.log(x); // let x: number

x = 'goodbye!';
console.log(x); // let x: string
```

Обратите внимание, что каждое из этих назначений является допустимым. Несмотря на то, что наблюдаемый тип `x` изменился на `number` после нашего первого назначения, мы все еще смогли назначить `string` для `x`. Это потому, что объявленный тип `x` — тип, с которого `x` начинался — это `string | number`, а назначаемость всегда проверяется по объявленному типу.

Если бы мы присвоили тип `boolean` для `x`, мы бы увидели ошибку, поскольку оно не было частью объявленного типа.

```ts
let x = Math.random() < 0.5 ? 10 : 'hello world!'; // let x: string | number

x = 1;
console.log(x); // let x: number

x = true; // Ошибка: Тип "boolean" не может быть назначен для типа "string | number".
console.log(x); // let x: string | number
```

## [Анализ потока](#сужение)

До этого момента мы рассмотрели несколько базовых примеров того, как TypeScript сужается в пределах определенных ветвей. Но происходит нечто большее, чем просто переход от каждой переменной и поиск защитников типов в `if`, `while`, условных операторах и т.д. Например:

```ts
function padLeft(padding: number | string, input: string) {
  if (typeof padding === 'number') {
    return ' '.repeat(padding) + input;
  }
  return padding + input;
}
```

`padLeft` вернет значение из первого блока `if`. TypeScript смог проанализировать этот код и увидеть, что остальная часть тела (`return padding + input`) недоступна в случае, когда `padding` является типом `number`. В результате удалось убрать `number` из типа `padding` (сужение от `string | number` к `string`) для остальной части функции.

Этот анализ кода, основанный на достижимости, называется `control flow analysis (анализ потока управления)`, и TypeScript использует этот анализ потока для сужения типов, поскольку он сталкивается с защитниками типов и присваиваниванием. Когда анализируется переменная, поток управления может разделяться и снова объединяться несколько раз, и можно наблюдать, что эта переменная имеет другой тип в каждой точке.

```ts
function example() {
  let x: string | number | boolean;
  x = Math.random() < 0.5;
  console.log(x); // let x: boolean

  if (Math.random() < 0.5) {
    x = 'hello';
    console.log(x); // let x: string
  } else {
    x = 100;
    console.log(x); // let x: number
  }

  return x; // let x: string | number
}
```

## [Использование type predicates](#сужение)

До сих пор мы работали с существующими конструкциями JavaScript, чтобы справиться с сужением, однако иногда вам нужен более прямой контроль над тем, как изменяются типы в вашем коде.
