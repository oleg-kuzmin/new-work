# [Подробнее о функциях](../index.md)

- [Введение](#введение)
- [Функциональное выражение](#функциональное-выражение)
- [Сигнатура вызова](#сигнатура-вызова)
- [Создание сигнатуры](#создание-сигнатуры)
- [Функции с дженериками](#функции-с-дженериками)
  - [Вывод](#вывод)

## [Введение](#подробнее-о-функциях)

Функции являются базовым строительным блоком любого приложения, будь то локальные функции, импортированные из другого модуля или методы класса. Они также являются значениями, и, как и другие значения, TypeScript имеет много способов описать, как могут вызываться функции. Давайте узнаем, как писать типы, описывающие функции.

## [Функциональное выражение](#подробнее-о-функциях)

Самый простой способ описать функцию — использовать функциональное выражение. Эти типы синтаксически похожи на стрелочные функции:

```ts
function greeter(fn: (a: string) => void) {
  fn('Hello, World');
}

function printToConsole(s: string) {
  console.log(s);
}

greeter(printToConsole);
```

Синтаксис `(a:string) => void` означает «функция с одним параметром с именем `a` типа `string`, которая не имеет возвращаемого значения». Как и в случае с объявлениями функций, если тип параметра не указан, он неявно является `any`.

Обратите внимание, что имя параметра является обязательным. Тип функции `(string) => void` означает «функция с параметром с именем `string` типа `any`»!

Конечно, мы можем использовать псевдоним типа для обозначения типа функции:

```ts
type GreetFunction = (a: string) => void;
function greeter(fn: GreetFunction) {
  // ...
}
```

## [Сигнатура вызова](#подробнее-о-функциях)

В JavaScript функции могут иметь свойства в дополнение к тому, что они могут быть вызваны. Однако синтаксис функционального выражения не позволяет объявлять свойства. Если мы хотим описать что-то вызываемое с помощью свойств, мы можем написать сигнатуру вызова в типе объекта:

```ts
type DescribableFunction = {
  description: string;
  (someArg: number): boolean;
};

function doSomething(fn: DescribableFunction) {
  console.log(fn.description + ' returned ' + fn(6));
}

function myFunc(someArg: number) {
  return someArg > 3;
}

myFunc.description = 'default description';

doSomething(myFunc);
```

Обратите внимание, что синтаксис немного отличается от функционального выражения — используйте `:` между списком параметров и типом возвращаемого значения, вместо `=>`.

## [Создание сигнатуры](#подробнее-о-функциях)

Функции JavaScript также можно вызывать с помощью оператора `new`. TypeScript называет их конструкторами, поскольку они обычно создают новый объект. Вы можете написать сигнатуру конструкции, добавив новое ключевое слово `new` перед сигнатурой вызова:

```ts
type SomeConstructor = {
  new (s: string): SomeObject;
};

function fn(ctor: SomeConstructor) {
  return new ctor('hello');
}
```

Некоторые объекты, например объект `Date` в JavaScript, можно вызывать с помощью `new` или без него. Вы можете произвольно комбинировать вызовы и создавать сигнатуры одного и того же типа:

```ts
interface CallOrConstruct {
  (n?: number): string;
  new (s: string): Date;
}
```

## [Функции с дженериками](#подробнее-о-функциях)

Обычно пишут функцию, в которой типы входных данных связаны с типом выходных данных или где типы двух входных данных каким-то образом связаны. Давайте на минутку рассмотрим функцию, которая возвращает первый элемент массива:

```ts
function firstElement(arr: any[]) {
  return arr[0];
}
```

Эта функция выполняет свою работу, но, к сожалению, имеет тип возвращаемого значения `any`. Было бы лучше, если бы функция возвращала тип элемента массива.

В TypeScript дженерики используются, когда мы хотим описать соответствие между двумя значениями. Мы делаем это, объявляя параметр типа в сигнатуре функции:

```ts
function firstElement<Type>(arr: Type[]): Type | undefined {
  return arr[0];
}
```

Добавив к этой функции параметр типа `Type` и используя его в двух местах, мы создали связь между входом функции (массивом) и выходом (возвращаемым значением). Теперь, когда мы его вызываем, получается более конкретный тип:

```ts
const s = firstElement(['a', 'b', 'c']); // 'string'
const n = firstElement([1, 2, 3]); // 'number'
const u = firstElement([]); // undefined
```

### [Вывод](#подробнее-о-функциях)
