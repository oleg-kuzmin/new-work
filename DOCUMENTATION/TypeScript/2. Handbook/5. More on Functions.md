# [Подробнее о функциях](../index.md)

- [Введение](#введение)
- [Функциональное выражение](#функциональное-выражение)
- [Сигнатура вызова](#сигнатура-вызова)
- [Создание сигнатуры](#создание-сигнатуры)
- [Функции с дженериками](#функции-с-дженериками)
  - [Вывод](#вывод)
  - [Ограничения](#ограничения)

## [Введение](#подробнее-о-функциях)

Функции являются базовым строительным блоком любого приложения, будь то локальные функции, импортированные из другого модуля или методы класса. Они также являются значениями, и, как и другие значения, TypeScript имеет много способов описать, как могут вызываться функции. Давайте узнаем, как писать типы, описывающие функции.

## [Функциональное выражение](#подробнее-о-функциях)

Самый простой способ описать функцию — использовать функциональное выражение. Эти типы синтаксически похожи на стрелочные функции:

```ts
function greeter(fn: (a: string) => void) {
  fn('Hello, World');
}

function printToConsole(s: string) {
  console.log(s);
}

greeter(printToConsole);
```

Синтаксис `(a:string) => void` означает «функция с одним параметром с именем `a` типа `string`, которая не имеет возвращаемого значения». Как и в случае с объявлениями функций, если тип параметра не указан, он неявно является `any`.

Обратите внимание, что имя параметра является обязательным. Тип функции `(string) => void` означает «функция с параметром с именем `string` типа `any`»!

Конечно, мы можем использовать псевдоним типа для обозначения типа функции:

```ts
type GreetFunction = (a: string) => void;
function greeter(fn: GreetFunction) {
  // ...
}
```

## [Сигнатура вызова](#подробнее-о-функциях)

В JavaScript функции могут иметь свойства в дополнение к тому, что они могут быть вызваны. Однако синтаксис функционального выражения не позволяет объявлять свойства. Если мы хотим описать что-то вызываемое с помощью свойств, мы можем написать сигнатуру вызова в типе объекта:

```ts
type DescribableFunction = {
  description: string;
  (someArg: number): boolean;
};

function doSomething(fn: DescribableFunction) {
  console.log(fn.description + ' returned ' + fn(6));
}

function myFunc(someArg: number) {
  return someArg > 3;
}

myFunc.description = 'default description';

doSomething(myFunc);
```

Обратите внимание, что синтаксис немного отличается от функционального выражения — используйте `:` между списком параметров и типом возвращаемого значения, вместо `=>`.

## [Создание сигнатуры](#подробнее-о-функциях)

Функции JavaScript также можно вызывать с помощью оператора `new`. TypeScript называет их конструкторами, поскольку они обычно создают новый объект. Вы можете написать сигнатуру конструкции, добавив новое ключевое слово `new` перед сигнатурой вызова:

```ts
type SomeConstructor = {
  new (s: string): SomeObject;
};

function fn(ctor: SomeConstructor) {
  return new ctor('hello');
}
```

Некоторые объекты, например объект `Date` в JavaScript, можно вызывать с помощью `new` или без него. Вы можете произвольно комбинировать вызовы и создавать сигнатуры одного и того же типа:

```ts
interface CallOrConstruct {
  (n?: number): string;
  new (s: string): Date;
}
```

## [Функции с дженериками](#подробнее-о-функциях)

Обычно пишут функцию, в которой типы входных данных связаны с типом выходных данных или где типы двух входных данных каким-то образом связаны. Давайте на минутку рассмотрим функцию, которая возвращает первый элемент массива:

```ts
function firstElement(arr: any[]) {
  return arr[0];
}
```

Эта функция выполняет свою работу, но, к сожалению, имеет тип возвращаемого значения `any`. Было бы лучше, если бы функция возвращала тип элемента массива.

В TypeScript дженерики используются, когда мы хотим описать соответствие между двумя значениями. Мы делаем это, объявляя параметр типа в сигнатуре функции:

```ts
function firstElement<Type>(arr: Type[]): Type | undefined {
  return arr[0];
}
```

Добавив к этой функции параметр типа `Type` и используя его в двух местах, мы создали связь между входом функции (массивом) и выходом (возвращаемым значением). Теперь, когда мы его вызываем, получается более конкретный тип:

```ts
const s = firstElement(['a', 'b', 'c']); // 'string'
const n = firstElement([1, 2, 3]); // 'number'
const u = firstElement([]); // undefined
```

### [Вывод](#подробнее-о-функциях)

Обратите внимание, что в этом примере нам не нужно было указывать `Type`. Тип был определен (выбран автоматически) с помощью TypeScript.

Мы также можем использовать несколько параметров типа. Например, автономная версия `map` будет выглядеть так:

```ts
function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
  return arr.map(func);
}

// Параметр 'n' это тип 'string'
// 'parsed' это тип 'number[]'
const parsed = map(['1', '2', '3'], n => parseInt(n));
```

Обратите внимание, что в этом примере TypeScript может вывести как тип параметра типа `Input` (из заданного массива `string`), так и параметр типа `Output` на основе возвращаемого значения функционального выражения (`number`).

### [Ограничения](#подробнее-о-функциях)

Мы написали несколько универсальных функций, которые могут работать с любым типом значений. Иногда мы хотим связать два значения, но можем работать только с определенным подмножеством значений. В этом случае мы можем использовать ограничение, чтобы ограничить типы, которые может принимать параметр типа.

Давайте напишем функцию, которая возвращает большее из двух значений. Для этого нам нужно свойство длины `length`, которое является числом. Мы ограничиваем параметр типа этим типом, написав `extends`:

```ts
function longest<Type extends { length: number }>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}

// longerArray это тип 'number[]'
const longerArray = longest([1, 2], [1, 2, 3]);
// longerString это тип 'alice' | 'bob'
const longerString = longest('alice', 'bob');

// Ошибка! Числа не имеют свойство 'length'
const notOK = longest(10, 100); // Аргумент типа "number" нельзя назначить параметру типа "{ length: number; }".
```

В этом примере следует отметить несколько интересных вещей. Мы разрешили TypeScript выводить возвращаемый тип `longest`. Вывод возвращаемого типа также работает с универсальными функциями.

Поскольку мы ограничили `Type` до `{ length: number }`, нам разрешили получить доступ к свойству `.length` параметров `a` и `b`. Без ограничения типа мы не смогли бы получить доступ к этим свойствам, поскольку значения могли бы иметь какой-то другой тип без свойства length.

Типы `longerArray` и `longerString` были выведены на основе аргументов. Помните, что дженерики — это связывание двух или более значений одного и того же типа!


