# [Сужение](../index.md)

- [Введение](#введение)
- [Typeof type guards](#typeof-type-guards)

## [Введение](#сужение)

Представьте, что у нас есть функция `PadLeft`.

```ts
function padLeft(padding: number | string, input: string): string {
  throw new Error('Not implemented yet!');
}
```

Если `padding` имеет тип `number`, он будет рассматриваться как количество пробелов, которые мы хотим добавить к `input`. Если `padding` имеет тип `string`, он должен просто добавить `padding` к `input`. Давайте попробуем реализовать логику, когда в `PadLeft` передается тип `number` для `padding`.

```ts
function padLeft(padding: number | string, input: string): string {
  return ' '.repeat(padding) + input;
  // Аргумент типа "string | number" нельзя назначить параметру типа "number".
  // Тип "string" не может быть назначен для типа "number".
}
```

Ой-ой, мы получаем ошибку в `padding`. TypeScript предупреждает нас, что мы передаем значение с типом `number | string` в функцию `repeat`, которая принимает только `number`, и это правильно. Другими словами, мы не проверяли явно, является ли `padding` типом `number`, и не обрабатываем случай, когда это тип `string`, поэтому давайте сделаем это.

```ts
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === 'number') {
    return ' '.repeat(padding) + input;
  }
  return padding + input;
}
```

Если это в основном выглядит как неинтересный код JavaScript, то в этом-то и суть. За исключением добавленных нами аннотаций, этот код TypeScript выглядит как JavaScript. Идея в том, что система типов TypeScript направлена ​​на то, чтобы максимально упростить написание типичного кода JavaScript, не выворачиваясь наизнанку ради обеспечения безопасности типов.

Хотя это может показаться не таким уж большим, на самом деле здесь происходит много всего под капотом. Подобно тому, как TypeScript анализирует значения во время выполнения с использованием статических типов, он накладывает анализ типов на конструкции потока управления во время выполнения JavaScript, такие как `if/else`, условные тернарные операторы, циклы, проверки истинности и т.д., которые могут влиять на эти типы.

---

В нашей проверке `if` TypeScript видит `typeof padding === "number"` и понимает это как особую форму кода, называемую `type guard`.

TypeScript отслеживает возможные пути выполнения, которые могут быть использованы нашими программами для анализа наиболее конкретного возможного типа значения в данной позиции.

Он рассматривает эти специальные проверки (называемые `type guards (защитники типа)`) и присвоения, а процесс уточнения типов до более конкретных типов, чем объявленные, называется `narrowing (сужение)`. Во многих редакторах мы можем наблюдать за изменениями этих типов, и мы даже сделаем это в наших примерах.

```ts
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === 'number') {
    return ' '.repeat(padding) + input;
    // параметр padding: number
  }
  return padding + input;
  // параметр padding: string
}
```

Существует несколько различных конструкций, которые TypeScript понимает для сужения.

## [Typeof type guards](#сужение)
