# Основы

- [Введение](#введение)
- [Статическая проверка типов](#статическая-проверка-типов)

## [Введение](#основы)

Добро пожаловать на первую страницу справочника. Если это ваш первый опыт работы с TypeScript, возможно, вы захотите начать с одного из руководств по [началу работы](<../Handbook/1. The TypeScript Handbook.md/#начало-работы>).

Каждое значение в JavaScript имеет набор вариантов поведения, которые вы можете наблюдать при выполнении различных операций. Это звучит абстрактно, но в качестве быстрого примера рассмотрим некоторые операции, которые мы можем выполнить над переменной с именем `message`.

```ts
// Доступ к свойству 'toLowerCase' в 'message' и его вызов
message.toLowerCase();

// Вызов 'message'
message();
```

Если мы разберем это, то первая работоспособная строка кода обращается к свойству `toLowerCase`, а затем вызывает его. Вторая пытается вызвать `message` напрямую.

Но если предположить, что мы не знаем значения `message` (а это довольно часто), мы не можем с уверенностью сказать, какие результаты мы получим при попытке запустить любой из этих кодов. Поведение каждой операции полностью зависит от того, какое значение мы имели изначально.

- Можно ли вызвать `message`?
- Есть ли у него свойство `toLowerCase`?
- Если да, то можно ли вообще вызвать `toLowerCase`?
- Если оба этих значения являются вызываемыми, что они возвращают?

Ответы на эти вопросы обычно мы держим в голове, когда пишем JavaScript, и нам нужно надеяться, что мы правильно поняли все детали.

Допустим, `message` было определено следующим образом.

```ts
const message = 'Hello World!';
```

Как вы, наверное, догадались, если мы попытаемся запустить `message.toLowerCase()`, мы получим ту же строку, только в нижнем регистре.

А как насчет второй строки кода? Если вы знакомы с JavaScript, вы знаете, что это не получиться с ошибкой:

```bash
TypeError: message is not a function
```

Было бы здорово, если бы мы могли избежать подобных ошибок.

Когда мы запускаем наш код, наш JavaScript в runtime выбирает, что делать, выясняя тип значения — какие виды поведения и возможности у него есть. Это часть того, на что намекает `TypeError` — он говорит, что строка `"Hello World!"` не может быть вызвана как функция.

Для некоторых значений, таких как примитивы `string` и `number`, мы можем определить их тип во время выполнения с помощью оператора `typeof`. Но для других вещей, таких как функции, нет соответствующего механизма времени выполнения для определения их типов. Например, рассмотрим эту функцию:

```ts
function fn(x) {
  return x.flip();
}
```

Мы можем заметить, прочитав код, что эта функция будет работать только если задан объект с вызываемым свойством `flip`, но JavaScript не выводит эту информацию на поверхность таким образом, чтобы мы могли проверить ее во время выполнения кода. Единственный способ в чистом JavaScript узнать, что `fn` делает с определенным значением, — это вызвать ее и посмотреть, что произойдет. Такое поведение затрудняет предсказание того, что будет делать код, до его запуска, что означает, что сложнее узнать, что будет делать ваш код, пока вы его пишете.

С этой точки зрения тип — это концепция описания того, какие значения могут быть переданы в `fn`, а какие приведут к сбою. JavaScript по-настоящему обеспечивает только динамическую типизацию — запуск кода, чтобы увидеть, что произойдет.

Альтернативой является использование системы статических типов для прогнозирования того, что ожидается от кода перед его запуском.

## [Статическая проверка типов](#основы)
