# Основы

- [Введение](#введение)
- [Статическая проверка типов](#статическая-проверка-типов)
- [Ошибки, не являющиеся исключениями](#ошибки-не-являющиеся-исключениями)
- [Типы для подсказок](#типы-для-подсказок)
- [tsc, компилятор TypeScript](#tsc-компилятор-typescript)
- [Выдача с ошибками](#выдача-с-ошибками)
- [Явные типы](#явные-типы)

## [Введение](#основы)

Добро пожаловать на первую страницу справочника. Если это ваш первый опыт работы с TypeScript, возможно, вы захотите начать с одного из руководств по [началу работы](<../Handbook/1. The TypeScript Handbook.md/#начало-работы>).

Каждое значение в JavaScript имеет набор вариантов поведения, которые вы можете наблюдать при выполнении различных операций. Это звучит абстрактно, но в качестве быстрого примера рассмотрим некоторые операции, которые мы можем выполнить над переменной с именем `message`.

```js
// Доступ к свойству 'toLowerCase' в 'message' и его вызов
message.toLowerCase();

// Вызов 'message'
message();
```

Если мы разберем это, то первая работоспособная строка кода обращается к свойству `toLowerCase`, а затем вызывает его. Вторая пытается вызвать `message` напрямую.

Но если предположить, что мы не знаем значения `message` (а это довольно часто), мы не можем с уверенностью сказать, какие результаты мы получим при попытке запустить любой из этих кодов. Поведение каждой операции полностью зависит от того, какое значение мы имели изначально.

- Можно ли вызвать `message`?
- Есть ли у него свойство `toLowerCase`?
- Если да, то можно ли вообще вызвать `toLowerCase`?
- Если оба этих значения являются вызываемыми, что они возвращают?

Ответы на эти вопросы обычно мы держим в голове, когда пишем JavaScript, и нам нужно надеяться, что мы правильно поняли все детали.

Допустим, `message` было определено следующим образом.

```ts
const message = 'Hello World!';
```

Как вы, наверное, догадались, если мы попытаемся запустить `message.toLowerCase()`, мы получим ту же строку, только в нижнем регистре.

А как насчет второй строки кода? Если вы знакомы с JavaScript, вы знаете, что это не получиться с ошибкой:

```bash
TypeError: message is not a function
```

Было бы здорово, если бы мы могли избежать подобных ошибок.

Когда мы запускаем наш код, JavaScript в runtime выбирает, что делать, выясняя тип значения — какие виды поведения и возможности у него есть. Это часть того, на что намекает `TypeError` — он говорит, что строка `"Hello World!"` не может быть вызвана как функция.

Для некоторых значений, таких как примитивы `string` и `number`, мы можем определить их тип во время выполнения с помощью оператора `typeof`. Но для других вещей, таких как функции, нет соответствующего механизма времени выполнения для определения их типов. Например, рассмотрим эту функцию:

```js
function fn(x) {
  return x.flip();
}
```

Мы можем заметить, прочитав код, что эта функция будет работать только если задан объект с вызываемым свойством `flip`, но JavaScript не выводит эту информацию на поверхность таким образом, чтобы мы могли проверить ее во время выполнения кода. Единственный способ в чистом JavaScript узнать, что `fn` делает с определенным значением, — это вызвать ее и посмотреть, что произойдет. Такое поведение затрудняет предсказание того, что будет делать код, до его запуска, что означает, что сложнее узнать, что будет делать ваш код, пока вы его пишете.

С этой точки зрения тип — это концепция описания того, какие значения могут быть переданы в `fn`, а какие приведут к сбою. JavaScript по-настоящему обеспечивает только динамическую типизацию — запуск кода, чтобы увидеть, что произойдет.

Альтернативой является использование системы статических типов для прогнозирования того, что ожидается от кода перед его запуском.

## [Статическая проверка типов](#основы)

Вспомните тот `TypeError`, который мы получили ранее, пытаясь вызвать `string` как функцию. Большинству людей не нравится получать какие-либо ошибки при запуске своего кода — это считается ошибками! И когда мы пишем новый код, мы стараемся изо всех сил избегать появления новых ошибок.

Если мы добавим немного кода, сохраним наш файл, перезапустим код и сразу увидим ошибку, мы можем быстро изолировать проблему; но это не всегда так. Мы могли недостаточно тщательно протестировать функцию, поэтому мы могли бы никогда не столкнуться с потенциальной ошибкой, которая могла бы быть выдана! Или, если бы нам повезло стать свидетелями ошибки, мы могли бы в конечном итоге провести большой рефакторинг и добавить много другого кода, в котором нам пришлось бы копаться.

В идеале у нас мог бы быть инструмент, который поможет нам находить эти ошибки до запуска нашего кода. Именно это и делает статический проверяющий тип, такой как TypeScript. Системы статических типов описывают формы и поведение того, какими будут наши значения при запуске наших программ. Такой проверяющий тип, как TypeScript, использует эту информацию и сообщает нам, когда что-то может пойти не так.

```ts
const message = 'hello!';
message();

// Это выражение не является вызываемым.
// Тип "String" не содержит сигнатуры вызова.
```

Запуск этого последнего примера с помощью TypeScript выдаст нам сообщение об ошибке, прежде чем мы запустим код.

## [Ошибки, не являющиеся исключениями](#основы)

До сих пор мы обсуждали определенные вещи, такие как ошибки runtime — случаи, когда среда выполнения JavaScript сообщает нам, что она считает что-то бессмысленным. Эти случаи возникают, потому что [спецификация ECMAScript](https://tc39.github.io/ecma262/) содержит явные инструкции о том, как язык должен себя вести, когда он сталкивается с чем-то неожиданным.

Например, спецификация гласит, что попытка вызвать что-то, что не может быть вызвано, должна выдать ошибку. Возможно, это звучит как «очевидное поведение», но вы можете представить, что доступ к свойству, которое не существует в объекте, также должен выдать ошибку. Вместо этого JavaScript дает нам другое поведение и возвращает значение `undefined`:

```js
const user = {
  name: 'Daniel',
  age: 26,
};
user.location; // возвращает undefined
```

В конечном счете, статическая система типов должна сделать вызов того, какой код должен быть помечен как ошибка в ее системе, даже если это «допустимый» JavaScript, который не выдаст ошибку немедленно. В TypeScript следующий код выдает ошибку о том, что местоположение не определено:

```ts
const user = {
  name: 'Daniel',
  age: 26,
};

user.location;
// Свойство "location" не существует в типе "{ name: string; age: number; }".
```

Хотя иногда это подразумевает компромисс в том, что вы можете выразить, цель состоит в том, чтобы обнаружить законные ошибки в наших программах. А TypeScript выявляет множество вполне допустимых ошибок.

Например: опечатки,

```ts
const announcement = 'Hello World!';

// Как быстро вы можете найти опечатки?
announcement.toLocaleLowercase();
announcement.toLocalLowerCase();

// Мы, вероятно, хотели написать это...
announcement.toLocaleLowerCase();
```

невызываемые функции,

```ts
function flipCoin() {
  // Предполагается, что это Math.random()
  return Math.random < 0.5;
  // Оператор "<" невозможно применить к типам "() => number" и "number".
}
```

или основные логические ошибки.

```ts
const value = Math.random() < 0.5 ? 'a' : 'b';
if (value !== 'a') {
  // ...
} else if (value === 'b') {
  // Это сравнение кажется непреднамеренным, поскольку типы ""a"" и ""b"" не перекрываются.
}
```

## [Типы для подсказок](#основы)

TypeScript может обнаруживать ошибки, когда мы допускаем ошибки в нашем коде. Это здорово, но TypeScript также может уберечь нас от подобных ошибок.

Средство проверки типов имеет информацию для проверки, например, обращаемся ли мы к нужным свойствам переменных и других свойств. Получив эту информацию, он также может начать предлагать, какие свойства вы, возможно, захотите использовать.

Это означает, что TypeScript можно использовать и для редактирования кода, а базовая программа проверки типов может выдавать сообщения об ошибках и завершать код по мере ввода в редакторе. Это часть того, на что люди часто ссылаются, когда говорят об инструментах TypeScript.

```ts
import express from 'express';
const app = express();

app.get('/', function (req, res) {
  // начните печатать res.sen и увидите подсказку
});

app.listen(3000);
```

TypeScript относится к инструментам серьезно, и это выходит за рамки автодополнений и ошибок при вводе текста. Редактор, поддерживающий TypeScript, может предоставлять «быстрые исправления» для автоматического исправления ошибок, рефакторинги для легкой реорганизации кода и полезные функции навигации для перехода к определениям переменной или поиска всех ссылок на заданную переменную. Все это построено поверх проверки типов и полностью кроссплатформенно, поэтому вполне вероятно, что [ваш любимый редактор поддерживает TypeScript](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support).

## [tsc, компилятор TypeScript](#основы)

Мы говорили о проверке типов, но еще не использовали нашу проверку типов. Давайте познакомимся с нашим новым другом `tsc` — компилятором TypeScript. Сначала нам нужно получить его через `npm`.

```bash
npm install -g typescript
```

При этом компилятор TypeScript будет установлен глобально. Вы можете использовать `npx` или аналогичные инструменты, если предпочитаете вместо этого запускать `tsc` из локального пакета `node_modules`.

Теперь давайте перейдем в пустую папку и попробуем написать нашу первую программу TypeScript: `hello.ts`:

##### hello.ts

```ts
// Приветствует мир.
console.log('Hello world!');
```

Обратите внимание: здесь нет излишеств; эта программа "hello world" выглядит идентично тому, что вы написали бы для программы "hello world" на JavaScript. А теперь давайте проверим его тип, выполнив команду `tsc`, которая была установлена ​​для нас пакетом `typescript`.

```bash
tsc hello.ts
```

Тада!

Подождите, что еще за «тада»? Мы запустили `tsc` и ничего не произошло! Что ж, ошибок типа не было, поэтому мы не получили никакого вывода в консоль и сообщать было не о чем.

Но проверьте еще раз — вместо этого мы получили какой-то выходной файл. Если мы посмотрим в наш текущий каталог, то увидим файл `hello.js` рядом с `hello.ts`. Это выходной файл нашего файла `hello.ts` после того, как `tsc` скомпилирует или преобразует его в простой файл JavaScript. А если мы проверим содержимое, то увидим, что выдает TypeScript после обработки файла `.ts`:

```js
// Приветствует мир.
console.log('Hello world!');
```

В этом случае TypeScript пришлось преобразовывать очень мало, поэтому он выглядит идентично тому, что мы написали. Компилятор пытается выдать чистый читаемый код, который выглядит так, как будто его написал бы человек. Хотя это не всегда так просто, TypeScript делает отступы последовательно, учитывает, когда наш код охватывает разные строки кода, и старается сохранять комментарии.

А что, если бы мы допустили ошибку проверки типов? Давайте перепишем `hello.ts`:

##### hello.ts

```ts
// Это функция приветствия общего назначения:
function greet(person, date) {
  console.log(`Hello ${person}, today is ${date}!`);
}

greet('Brendan');
```

Если мы снова запустим `tsc hello.ts`, обратите внимание, что мы получим ошибку в командной строке!

```bash
Expected 2 arguments, but got 1.
```

TypeScript сообщает нам, что мы забыли передать аргумент функции приветствия, и это правильно. До сих пор мы писали только стандартный JavaScript, но проверка типов по-прежнему позволяла обнаруживать проблемы в нашем коде. Спасибо TypeScript!

## [Выдача с ошибками](#основы)

Одна вещь, которую вы могли не заметить в последнем примере, это то, что наш файл `hello.js` снова изменился. Если мы откроем этот файл, то увидим, что его содержимое по сути осталось таким же, как и в нашем входном файле. Это может быть немного удивительно, учитывая тот факт, что `tsc` сообщил об ошибке в нашем коде, но это основано на одной из основных ценностей TypeScript: в большинстве случаев вы будете знать лучше, чем TypeScript.

Повторяя то, что было сказано ранее, код проверки типов ограничивает виды программ, которые вы можете запустить, и поэтому есть компромисс относительно того, какие вещи проверка типов считает приемлемыми. В большинстве случаев это нормально, но есть сценарии, когда эти проверки мешают. Например, представьте, что вы переносите код JavaScript на TypeScript и вносите ошибки проверки типов. В конце концов вы доберетесь до очистки для проверки типов, но этот исходный код JavaScript уже работал! Почему его преобразование в TypeScript должно помешать вам запустить его?

Так что TypeScript не будет вам мешать. Конечно, со временем вы можете захотеть быть немного более защищенным от ошибок и заставить TypeScript действовать немного строже. В этом случае вы можете использовать опцию компилятора `noEmitOnError`. Попробуйте изменить файл `hello.ts` и запустить `tsc` с этим флагом:

```bash
tsc --noEmitOnError hello.ts
```

Вы заметите, что `hello.js` никогда не обновляется.

## [Явные типы](#основы)

До сих пор мы не сообщали TypeScript, что такое `person` или `date`. Давайте отредактируем код, чтобы сообщить TypeScript, что `person` — это `string`, а `date` должна быть объектом `Date`. Мы также будем использовать метод `toDateString()` для `date`.

##### hello.ts

```ts
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
```

Мы добавили аннотации типов для `person` и `date`, чтобы описать, с какими типами значений можно вызывать `greet`. Вы можете прочитать эту подпись как "приветствие принимает `person` типа `string` и `date` типа `Date`".

Благодаря этому TypeScript может рассказать нам о других случаях, когда `greet` могло быть вызвано неправильно. Например…

##### hello.ts

```ts
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

greet('Maddison', Date());
// Аргумент типа "string" нельзя назначить параметру типа "Date".
```

Хм? TypeScript сообщил об ошибке во втором аргументе, но почему?

Возможно, это удивительно, но вызов `Date()` в JavaScript возвращает `string`. С другой стороны, построение `Date` с помощью `new Date()` фактически дает нам то, что мы ожидали.

В любом случае, мы можем быстро исправить ошибку:

##### hello.ts

```ts
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

greet('Maddison', new Date());
```

Имейте в виду, что нам не всегда нужно писать явные аннотации типов. Во многих случаях TypeScript может даже просто вывести (или «вычислить») типы за нас, даже если мы их опустим.

```ts
let msg = 'hello there!'; // let msg: string
```

Несмотря на то, что мы не сообщили TypeScript, что `msg` имеет тип `string`, он смог это выяснить. Это особенность, и лучше не добавлять аннотации, если система типов все равно выведет тот же тип.

Примечание. Cообщение в комментарии внутри предыдущего кода — это то, что редактор отобразил бы при наведении курсора на слово.

