# Основы

- [Введение](#введение)
- [Статическая проверка типов](#статическая-проверка-типов)
- [Ошибки, не являющиеся исключениями](#ошибки-не-являющиеся-исключениями)
- [Типы оснастки](#типы-оснастки)

## [Введение](#основы)

Добро пожаловать на первую страницу справочника. Если это ваш первый опыт работы с TypeScript, возможно, вы захотите начать с одного из руководств по [началу работы](<../Handbook/1. The TypeScript Handbook.md/#начало-работы>).

Каждое значение в JavaScript имеет набор вариантов поведения, которые вы можете наблюдать при выполнении различных операций. Это звучит абстрактно, но в качестве быстрого примера рассмотрим некоторые операции, которые мы можем выполнить над переменной с именем `message`.

```ts
// Доступ к свойству 'toLowerCase' в 'message' и его вызов
message.toLowerCase();

// Вызов 'message'
message();
```

Если мы разберем это, то первая работоспособная строка кода обращается к свойству `toLowerCase`, а затем вызывает его. Вторая пытается вызвать `message` напрямую.

Но если предположить, что мы не знаем значения `message` (а это довольно часто), мы не можем с уверенностью сказать, какие результаты мы получим при попытке запустить любой из этих кодов. Поведение каждой операции полностью зависит от того, какое значение мы имели изначально.

- Можно ли вызвать `message`?
- Есть ли у него свойство `toLowerCase`?
- Если да, то можно ли вообще вызвать `toLowerCase`?
- Если оба этих значения являются вызываемыми, что они возвращают?

Ответы на эти вопросы обычно мы держим в голове, когда пишем JavaScript, и нам нужно надеяться, что мы правильно поняли все детали.

Допустим, `message` было определено следующим образом.

```ts
const message = 'Hello World!';
```

Как вы, наверное, догадались, если мы попытаемся запустить `message.toLowerCase()`, мы получим ту же строку, только в нижнем регистре.

А как насчет второй строки кода? Если вы знакомы с JavaScript, вы знаете, что это не получиться с ошибкой:

```bash
TypeError: message is not a function
```

Было бы здорово, если бы мы могли избежать подобных ошибок.

Когда мы запускаем наш код, JavaScript в runtime выбирает, что делать, выясняя тип значения — какие виды поведения и возможности у него есть. Это часть того, на что намекает `TypeError` — он говорит, что строка `"Hello World!"` не может быть вызвана как функция.

Для некоторых значений, таких как примитивы `string` и `number`, мы можем определить их тип во время выполнения с помощью оператора `typeof`. Но для других вещей, таких как функции, нет соответствующего механизма времени выполнения для определения их типов. Например, рассмотрим эту функцию:

```ts
function fn(x) {
  return x.flip();
}
```

Мы можем заметить, прочитав код, что эта функция будет работать только если задан объект с вызываемым свойством `flip`, но JavaScript не выводит эту информацию на поверхность таким образом, чтобы мы могли проверить ее во время выполнения кода. Единственный способ в чистом JavaScript узнать, что `fn` делает с определенным значением, — это вызвать ее и посмотреть, что произойдет. Такое поведение затрудняет предсказание того, что будет делать код, до его запуска, что означает, что сложнее узнать, что будет делать ваш код, пока вы его пишете.

С этой точки зрения тип — это концепция описания того, какие значения могут быть переданы в `fn`, а какие приведут к сбою. JavaScript по-настоящему обеспечивает только динамическую типизацию — запуск кода, чтобы увидеть, что произойдет.

Альтернативой является использование системы статических типов для прогнозирования того, что ожидается от кода перед его запуском.

## [Статическая проверка типов](#основы)

Вспомните тот `TypeError`, который мы получили ранее, пытаясь вызвать `string` как функцию. Большинству людей не нравится получать какие-либо ошибки при запуске своего кода — это считается ошибками! И когда мы пишем новый код, мы стараемся изо всех сил избегать появления новых ошибок.

Если мы добавим немного кода, сохраним наш файл, перезапустим код и сразу увидим ошибку, мы можем быстро изолировать проблему; но это не всегда так. Мы могли недостаточно тщательно протестировать функцию, поэтому мы могли бы никогда не столкнуться с потенциальной ошибкой, которая могла бы быть выдана! Или, если бы нам повезло стать свидетелями ошибки, мы могли бы в конечном итоге провести большой рефакторинг и добавить много другого кода, в котором нам пришлось бы копаться.

В идеале у нас мог бы быть инструмент, который поможет нам находить эти ошибки до запуска нашего кода. Именно это и делает статический проверяющий тип, такой как TypeScript. Системы статических типов описывают формы и поведение того, какими будут наши значения при запуске наших программ. Такой проверяющий тип, как TypeScript, использует эту информацию и сообщает нам, когда что-то может пойти не так.

```ts
const message = 'hello!';
message();

// Это выражение не является вызываемым.
// Тип "String" не содержит сигнатуры вызова.
```

Запуск этого последнего примера с помощью TypeScript выдаст нам сообщение об ошибке, прежде чем мы запустим код.

## [Ошибки, не являющиеся исключениями](#основы)

До сих пор мы обсуждали определенные вещи, такие как ошибки runtime — случаи, когда среда выполнения JavaScript сообщает нам, что она считает что-то бессмысленным. Эти случаи возникают, потому что [спецификация ECMAScript](https://tc39.github.io/ecma262/) содержит явные инструкции о том, как язык должен себя вести, когда он сталкивается с чем-то неожиданным.

Например, спецификация гласит, что попытка вызвать что-то, что не может быть вызвано, должна выдать ошибку. Возможно, это звучит как «очевидное поведение», но вы можете представить, что доступ к свойству, которое не существует в объекте, также должен выдать ошибку. Вместо этого JavaScript дает нам другое поведение и возвращает значение `undefined`:

```ts
const user = {
  name: 'Daniel',
  age: 26,
};
user.location; // возвращает undefined
```

В конечном счете, статическая система типов должна сделать вызов того, какой код должен быть помечен как ошибка в ее системе, даже если это «допустимый» JavaScript, который не выдаст ошибку немедленно. В TypeScript следующий код выдает ошибку о том, что местоположение не определено:

```ts
const user = {
  name: 'Daniel',
  age: 26,
};

user.location;
// Свойство "location" не существует в типе "{ name: string; age: number; }"
```

Хотя иногда это подразумевает компромисс в том, что вы можете выразить, цель состоит в том, чтобы обнаружить законные ошибки в наших программах. А TypeScript выявляет множество вполне допустимых ошибок.

Например: опечатки,

```ts
const announcement = 'Hello World!';

// Как быстро вы можете найти опечатки?
announcement.toLocaleLowercase();
announcement.toLocalLowerCase();

// Мы, вероятно, хотели написать это...
announcement.toLocaleLowerCase();
```

невызываемые функции,

```ts
function flipCoin() {
  // Предполагается, что это Math.random()
  return Math.random < 0.5;
  // Оператор "<" невозможно применить к типам "() => number" и "number"
}
```

или основные логические ошибки.

```ts
const value = Math.random() < 0.5 ? 'a' : 'b';
if (value !== 'a') {
  // ...
} else if (value === 'b') {
  // Это сравнение кажется непреднамеренным, поскольку типы ""a"" и ""b"" не перекрываются.
}
```

## [Типы оснастки](#основы)

