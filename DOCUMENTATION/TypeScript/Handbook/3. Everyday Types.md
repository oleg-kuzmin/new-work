# [Повседневные типы](../index.md)

- [Введение](#введение)
- [Примитивы: string, number и boolean](#примитивы-string-number-и-boolean)
- [Массивы](#массивы)
- [Тип any](#тип-any)
  - [noImplicitAny](#noimplicitany)
- [Аннотация типов на переменных](#аннотация-типов-на-переменных)
- [Функции](#функции)
  - [Аннотации типов параметров](#аннотации-типов-параметров)
  - [Аннотации типов возвращаемых данных](#аннотации-типов-возвращаемых-данных)
  - [Анонимные функции](#анонимные-функции)
- [Тип object](#тип-object)
  - [Опциональные свойства](#опциональные-свойства)
- [Тип union](#тип-union)
  - [Определение типа union](#определение-типа-union)
  - [Работа с типом union](#работа-с-типом-union)
- [Псевдонимы типов](#псевдонимы-типов)
- [Интерфейсы](#интерфейсы)

## [Введение](#повседневные-типы)

В этой главе мы рассмотрим некоторые из наиболее распространенных типов значений, которые вы найдете в коде JavaScript, и объясним соответствующие способы описания этих типов в TypeScript. Это не исчерпывающий список, и в будущих главах будут описаны дополнительные способы именования и использования других типов.

Типы могут появляться не только в аннотациях типов, но и во многих других местах. По мере того, как мы узнаем о самих типах, мы также узнаем о местах, где мы можем ссылаться на эти типы для формирования новых конструкций.

Мы начнем с обзора самых основных и распространенных типов, с которыми вы можете столкнуться при написании кода JavaScript или TypeScript. Позже они сформируют основные строительные блоки более сложных типов.

## [Примитивы: string, number и boolean](#повседневные-типы)

В JavaScript есть три очень часто используемых [примитива](https://developer.mozilla.org/en-US/docs/Glossary/Primitive): `string`, `number` и `boolean`. Каждому из них соответствует тип в TypeScript. Как и следовало ожидать, это те же имена, которые вы бы увидели, если бы использовали оператор JavaScript `typeof` для значения этих типов:

- `string` представляет строковые значения, такие как `"Hello, world"`
- `number` предназначен для чисел типа `42`. В JavaScript нет специального значения для целых чисел, поэтому нет эквивалента `int` или `float` — все числа просто `number`.
- `boolean` используется для двух значений `true` и `false`

Имена типов `String`, `Number` и `Boolean` (начинающиеся с заглавных букв) допустимы, но относятся к некоторым специальным встроенным типам, которые очень редко встречаются в вашем коде. Для типов всегда используйте `string`, `number` или `boolean`.

## [Массивы](#повседневные-типы)

Чтобы указать тип массива, например `[1, 2, 3]`, можно использовать синтаксис `number[]`, этот синтаксис работает для любого типа (например, `string[]` — это массив строк и т. д.). Вы также можете увидеть это в записи `Array<number>`, что означает то же самое. Мы узнаем больше о синтаксисе `T<U>`, когда рассмотрим `generics`.

Обратите внимание, что `[number]` — это другое, подробнее в разделе [Tuples](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types).

## [Тип any](#повседневные-типы)

В TypeScript также есть специальный тип `any`, который вы можете использовать, когда не хотите, чтобы определенное значение вызывало ошибки проверки типов.

Когда значение имеет тип `any`, вы можете получить доступ к любым его свойствам (которые, в свою очередь, тоже будут иметь тип `any`), вызвать его как функцию, присвоить его значению любого типа (или из него) или сделать что угодно еще, это синтаксически законно:

```ts
let obj: any = { x: 0 };
// Ни одна из следующих строк кода не вызовет ошибки в компиляторе.
// Использование `any` отключает все дальнейшие проверки типов, и предполагается
// что, вы знаете код лучше, чем TypeScript.
obj.foo();
obj();
obj.bar = 100;
obj = 'hello';
const n: number = obj;
```

Тип `any` полезен, когда вы не хотите писать длинный тип только для того, чтобы убедить TypeScript в том, что определенная строка кода в порядке.

### [noImplicitAny](#повседневные-типы)

Если вы не указываете тип и TypeScript не может вывести его из контекста, компилятор обычно по умолчанию выбирает `any`.

Однако обычно этого следует избегать, поскольку `any` не проверяется по типу. Используйте флаг компилятора [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny), чтобы пометить любое неявное `any` как ошибку.

## [Аннотация типов на переменных](#повседневные-типы)

Когда вы объявляете переменную с помощью `const`, `var` или `let`, вы можете при желании добавить аннотацию типа, чтобы явно указать тип переменной:

```ts
let myName: string = 'Alice';
```

TypeScript не использует объявления типов слева, такие как `int x = 0`; Аннотации типов всегда идут **после** набираемого объекта.

Однако в большинстве случаев в этом нет необходимости. Везде, где это возможно, TypeScript пытается автоматически определить типы в вашем коде. Например, тип переменной определяется на основе типа ее инициализатора:

```ts
// Аннотация типа не требуется - 'myName' выводится как тип 'string'
let myName = 'Alice';
```

По большей части вам не нужно специально изучать правила логического вывода. Если вы только начинаете, попробуйте использовать меньше аннотаций типов, чем вы думаете — вы можете быть удивлены, насколько мало вам нужно TypeScript, чтобы полностью понять, что происходит.

## [Функции](#повседневные-типы)

Функции являются основным средством передачи данных в JavaScript. TypeScript позволяет указывать типы как входных, так и выходных значений функций.

### [Аннотации типов параметров](#повседневные-типы)

Когда вы объявляете функцию, вы можете добавить аннотации типа после каждого параметра, чтобы объявить, какие типы параметров принимает функция. Аннотации типов параметров указываются после имени параметра:

```ts
// Аннотация типа параметров
function greet(name: string) {
  console.log('Hello, ' + name.toUpperCase() + '!!');
}
```

Если параметр имеет аннотацию типа, будут проверены аргументы этой функции:

```ts
// Это было бы ошибкой в runtime если выполнить код!
greet(42); // Аргумент типа "number" нельзя назначить параметру типа "string".
```

Даже если в ваших параметрах нет аннотаций типов, TypeScript все равно проверит, что вы передали правильное количество аргументов.

### [Аннотации типов возвращаемых данных](#повседневные-типы)

Вы также можете добавить аннотации типа возвращаемого значения. Аннотации типа возвращаемого значения указываются после списка параметров:

```ts
function getFavoriteNumber(): number {
  return 26;
}
```

Как и в случае с аннотациями типов переменных, вам обычно не требуется аннотация типа возвращаемого значения, поскольку TypeScript определит тип возвращаемого значения функции на основе ее операторов `return`. Аннотация типа возвращаемого значения функции в приведенном выше примере ничего не меняет. В некоторых кодовых базах явно указывается тип возвращаемого значения для документации, предотвращения случайных изменений или просто по личным предпочтениям.

#### Функции, возвращающие `Promise`

Если вы хотите указать тип возвращаемого значения функции, которая возвращает `promise`, вам следует использовать тип `Promise`:

```ts
async function getFavoriteNumber(): Promise<number> {
  return 26;
}
```

### [Анонимные функции](#повседневные-типы)

Анонимные функции немного отличаются от декларации функций. Когда функция появляется там, где TypeScript может определить, как она будет вызываться, параметрам этой функции автоматически присваиваются типы.

Вот пример:

```ts
const names = ['Alice', 'Bob', 'Eve'];

// Контекстная типизация для функции - параметр s получает тип string
names.forEach(function (s) {
  console.log(s.toUpperCase());
});

// Контекстная типизация также применяется и к стрелочным функциям
names.forEach(s => {
  console.log(s.toUpperCase());
});
```

Несмотря на то, что параметр `s` не имел аннотации типа, TypeScript использовал типы функции `forEach` вместе с предполагаемым типом массива, чтобы определить тип, который будет иметь `s`.

Этот процесс называется `contextual typing (контекстной типизацией)`, поскольку контекст, в котором возникла функция, сообщает, какой тип она должна иметь.

Подобно правилам вывода, вам не нужно явно изучать, как это происходит, но понимание того, что это происходит, может помочь вам заметить, когда аннотации типов не нужны. Позже мы увидим больше примеров того, как контекст, в котором встречается значение, может влиять на его тип.

## [Тип object](#повседневные-типы)

Помимо примитивов, наиболее распространенным типом, с которым вы столкнетесь, является тип `object`. Это относится к любому значению JavaScript со свойствами, а это почти все из них! Чтобы определить тип `object`, мы просто перечисляем его свойства и их типы.

Например, вот функция, которая принимает точечный объект:

```ts
// Аннотация типа параметра является типом object
function printCoord(pt: { x: number; y: number }) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}
printCoord({ x: 3, y: 7 });
```

Здесь мы присвоили параметру аннотацию типа с двумя свойствами — `x` и `y`, оба из которых имеют тип `number`. Вы можете использовать знаки `,` или `;` для разделения свойств, а последний разделитель в любом случае не является обязательным.

Указание типов для каждого свойства объекта также не является обязательным. Если вы не укажете тип, он будет считаться `any`.

### [Опциональные свойства](#повседневные-типы)

Типы объектов также могут указывать, что некоторые или все их свойства являются необязательными. Для этого добавьте знак `?` после имени свойства:

```ts
function printName(obj: { first: string; last?: string }) {
  // ...
}
// Оба ОК
printName({ first: 'Bob' });
printName({ first: 'Alice', last: 'Alisson' });
```

В JavaScript, если вы обращаетесь к несуществующему свойству, вы получите значение `undefined`, а не ошибку в runtime. Из-за этого при чтении из необязательного свойства вам придется проверять наличие `undefined` перед его использованием.

```ts
function printName(obj: { first: string; last?: string }) {
  // Ошибка - может быть сбой, если 'obj.last отсутствует!
  console.log(obj.last.toUpperCase()); // Возможно, "obj.last" имеет значение undefined.

  if (obj.last !== undefined) {
    console.log(obj.last.toUpperCase()); // OK
  }

  // Безопасная альтернатива с использованием современного синтаксиса JavaScript:
  console.log(obj.last?.toUpperCase());
}
```

## [Тип union](#повседневные-типы)

Система типов TypeScript позволяет создавать новые типы из существующих, используя большое количество операторов. Теперь, когда мы знаем, как написать несколько типов, пришло время начать их интересным образом комбинировать.

### [Определение типа union](#повседневные-типы)

Первый способ объединения типов, который вы можете встретить, — это тип `union`. Тип `union` — это тип, образованный из двух или более других типов и представляющий значения, которые могут быть любыми из этих типов. Мы называем их `union’s members (члены union)`.

Давайте напишем функцию, которая может работать со строками или числами:

```ts
function printId(id: number | string) {
  console.log('Your ID is: ' + id);
}
// OK
printId(101);
// OK
printId('202');
// Error
printId({ myID: 22342 });

// Аргумент типа "{ myID: number; }" нельзя назначить параметру типа "string | number".
```

### [Работа с типом union](#повседневные-типы)

Предоставить значение, соответствующее типу `union`, легко — просто укажите тип, соответствующий любому из членов `union`. Если у вас есть значение типа `union`, как с ним работать?

TypeScript разрешит операцию только в том случае, если она валидна для каждого члена `union`. Например, если у вас есть `string | number`, вы не можете использовать методы, доступные только для `string`:

```ts
function printId(id: number | string) {
  console.log(id.toUpperCase());
}
// Свойство "toUpperCase" не существует в типе "string | number".
// Свойство "toUpperCase" не существует в типе "number".
```

Решение состоит в том, чтобы сделать `narrowing (сужение)` `union` с кодом, так же, как вы это делаете в JavaScript без аннотаций типов. Сужение происходит, когда TypeScript может определить более конкретный тип значения на основе структуры кода.

Например, TypeScript знает, что `typeof` только для строк будет возвращать значение `string`:

```ts
function printId(id: number | string) {
  if (typeof id === 'string') {
    // В этой ветке ID имеет тип 'string'
    console.log(id.toUpperCase());
  } else {
    // Здесь ID имеет тип 'number'
    console.log(id);
  }
}
```

Другой пример — использование такой функции, как `Array.isArray`:

```ts
function welcomePeople(x: string[] | string) {
  if (Array.isArray(x)) {
    // Здесь: 'x' это 'string[]'
    console.log('Hello, ' + x.join(' and '));
  } else {
    // Здесь: 'x' это 'string'
    console.log('Welcome lone traveler ' + x);
  }
}
```

Обратите внимание, что в ветке `else` нам не нужно делать ничего особенного — если `x` не является `string[]`, то логически остается просто `string`.

Иногда у вас будет `union`, в котором все члены имеют что-то общее. Например, и массивы, и строки имеют метод `slice`. Если каждый член `union` имеет общее свойство, вы можете использовать это свойство без сужения:

```ts
// Возвращаемый тип выводится как number[] | string
function getFirstThree(x: number[] | string) {
  return x.slice(0, 3);
}
```

Может показаться странным, что `union`, по-видимому, имеет `intersection (пересечение)` свойств этих типов. Это не случайно — название `union` происходит из теории типов. `union` из `number | string` составляется путем взятия `union` значений из каждого типа. Обратите внимание, что при наличии двух наборов с соответствующими фактами о каждом наборе только `intersection (пересечение)` этих фактов применимо к объединению самих наборов. Например, если у нас есть комната с высокими людьми в шляпах и другая комната с испанцами в шляпах, то после объединения этих комнат единственное, что мы знаем о каждом человеке, — это то, что он должен быть в шляпе.

## [Псевдонимы типов](#повседневные-типы)

Мы использовали типы объектов и типы `union`, записывая их непосредственно в аннотациях типов. Это удобно, но часто хочется использовать один и тот же тип более одного раза и ссылаться на него по одному имени.

`type alias (Псевдоним типа)` — это имя для любого типа. Синтаксис псевдонима типа такой:

```ts
type Point = {
  x: number;
  y: number;
};

// Точно так же, как и более ранний пример
function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

printCoord({ x: 100, y: 100 });
```

Фактически вы можете использовать псевдоним, чтобы дать имя любому типу, а не только объекту. Например, псевдоним может включать тип `union`:

```ts
type ID = number | string;
```

Обратите внимание, что псевдонимы - это всего лишь псевдонимы - вы не можете использовать псевдонимы типов для создания разных “версий” одного и того же типа. Когда вы используете псевдоним, это то же самое, как если бы вы написали тип напрямую.

Например, код ниже может выглядеть незаконным, но в соответствии с TypeScript он подходит, поскольку оба типа являются псевдонимами для одного и того же типа:

```ts
// sanitizeInput - очистка данных перед рендерингом
type UserInputSanitizedString = string;

function sanitizeInput(str: string): UserInputSanitizedString {
  return sanitize(str);
}

// Создаем очищенный input
let userInput = sanitizeInput(getInput());

// Однако он все еще может быть переопределен с помощью строки
userInput = 'new input';
```

## [Интерфейсы](#повседневные-типы)
