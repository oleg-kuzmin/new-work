# [`Тип object`](../index.md)

Тип `object` (для более сложных структур данных) называется ссылочными (они хранятся по ссылке).

В объектах хранят коллекции данных или более сложные структуры.

Массивы и функции это также объекты.

Когда нам нужно ключ объекта указать динамически, мы используем квадратные скобки.

## Создание объекта

Объекты, созданные через фигурные скобки и через `new Object()` совершенно идентичны.

Имена свойств (иногда их называют ключи, или поля) могут быть либо строками, либо символами. Если использовать в качестве ключа другой тип данных, то он будет приведён к строке с помощью вызова метода `toString()`.

Если ключ содержит пробел, то обращаться к нему возможно только через синтаксис квадратных скобок.

```js
//* Объявление переменной
const сat = {
  name: 'Том',
  age: 3,
  isBlack: true,
  kittens: ['Беляш', 'Михаил', 'Чарли'],
  favoriteToy: {
    name: 'мячик',
    size: 'маленький',
  },

  // Новый синтаксис записи метода
  meow() {
    console.log('мяу мяу');
  },

  // Старый синтаксис записи метода
  meow: function () {
    console.log('мяу мяу');
  },

  // Старый синтаксис записи метода
  goSleep: () => {
    console.log('Zzz');
  },
};
```

```js
const user = {
  // Новый синтаксис записи свойств
  firstName,
  username,

  // Старый синтаксис записи свойств
  firstName: firstName,
  username: username,
};
```

```js
// Конструктор
const myObject = new Object();
const book = new Object({ title: 'Война и мир', author: 'Лев Толстой' });
```

## Ключи объекта

Ключем объекта может быть строка, число, символ или переменная из этих значений.

Для записи символа нужны квадратные скобки.

Если прочитать свойство, которого нет у объекта, то вернётся `undefined`.

Если попытаться у свойства, котороe `undefined`, еще дальше получить еще какое-то свойство, то мы получим ошибку `"Cannot read properties of undefined"`. Избежать этого можно использовав синтаксис опциональной цепочки.

Если ключ содержит пробел, то обращаться к нему возможно только через квадратные скобки `[some some]`.

Если при записи нового свойства мы передаём значение ключа, которое не является строкой, оно автоматически преобразуется в строку. И наоборот — если при доступе к свойству в квадратных скобках указать значение, не являющееся строкой, оно преобразуется в строку.

### Обращение к свойству через точку

```js
const book = {
  title: 'Капитанская дочка',
};

console.log(`На полке стоит «${book.title}»`);
```

### Обращение к свойству через квадратные скобки

```js
const book = {
  title: 'Капитанская дочка',
};

console.log(book['title']);
console.log(`На полке стоит «${book['title']}»`);
```

### Добавление/изменение свойства через точку

```js
const bookExample = {
  title: 'Капитанская дочка',
};

bookExample.author = 'А.С.Пушкин'; // добавляем новое свойство
bookExample.title = 'Сказка о царе Салтане'; // изменяем существующее
```

### Добавление/изменение свойства через квадратные скобки

```js
const bookExample = {
  title: 'Капитанская дочка',
};

book['author'] = 'А.С.Пушкин'; // добавляем новое свойство
book['title'] = 'Сказка о царе Салтане'; // изменяем существующее
```

### Нестандартные ключи

```js
const obj = {
  simpleName: true,
  'как хочу, так и называю': true,
  '123anarchy!!!': true,
};

obj['как хочу, так и называю']; // true
obj['123anarchy!!!']; // true
```

### Cинтаксис опциональной цепочки `?`

- `object?.prop` - возвращает `object.prop` если объект не равен null или undefined, в противном случае `undefined`.
- `object?.[prop]` - возвращает `object.[prop]` если объект не равен null или undefined, в противном случае `undefined`.
- `object?.prop?.name` - возвращает `object.prop.name` если объект не равен null или undefined, в противном случае `undefined`.
- `obj.method?.()` - возвращает `object.method()`, если объект не равен null или undefined, в противном случае `undefined`.

## Копирование объекта

### Поверхностное копирование

```js
const copy = Object.assign({}, profit);
```

### Поверхностное копирование (spread-оператор)

```js
const copy = { ...person };
```

### Глубокое копирование (JSON)

У этого метода есть ограничение — копируемые поля объекта должны быть сериализуемы.

Вот примеры несериализуемых полей: `undefined`, `function`, `symbol`. При вызове `JSON.stringify` для этих полей мы получим `undefined`.

Массивы и объекты - сериализуемы. Но что будет если у них в качестве ключа или значения несериализуемые данные?

- для массивов: такие значения будут превращены в `null`;
- для объектов: такие значения будут опущены, а если `symbol` является ключом объекта, то он будет проигнорирован, даже при использовании функции `replacer`.

```js
const deepCopy = JSON.parse(JSON.stringify(profit));
```

## Сравнение объектов

Объекты — ссылочный тип данных.

При сравнении двух объектов JavaScript сравнивает не значения свойств этих объектов, а ссылки (адреса в памяти, по которым эти объекты хранятся). Поэтому любое сравнение двух объектов по разным ссылкам будет возвращать `false`, даже если они выглядят одинаково.

Сравнение будет возвращать `true`, только если мы сравниваем переменные, указывающие на один и тот же объект.

```js
const book = { title: 'Дюна' }; // создаётся один объект
const anotherBook = { title: 'Дюна' }; // создаётся другой объект
console.log(book === anotherBook); // false
```

```js
const book = { title: 'Дюна' }; // создаётся один объект
const anotherBook = book; // в anotherBook записывается ссылка на первый объект
console.log(book === anotherBook); // true
```
