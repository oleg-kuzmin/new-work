# [`Что такое this`](../index.md)

`this` — ключевое слово, которое используется для доступа к полям объекта внутри метода. При обращении к this возвращается ссылка на объект, внутри которого реализовано это обращение.

значение `this` определяется не в момент объявления, а в момент выполнения.

```js
const object = {
  prop: 'Свойство',
  method: function () {
    console.log(this);
  },
};

object.method(); // object
```

## 1. Привязка по умолчанию - вызов функции

Это тот случай, когда вы просто вызываете функцию по её имени. Тогда `this` принимает одно из двух значений:

- `undefined` — в строгом режиме
- объект `window` — в обычном

```js
function globalFunction() {
  console.log(this);
}
globalFunction(); // window
```

## 2. Неявная привязка - вызов метода объекта

Обратите внимание, что мы изменили точку вызова функции. Раньше мы вызывали её из глобальной области видимости, а теперь — как метод объекта `window`. Так мы неявно указали контекст — `window`. При использовании неявной привязки определить контекст `this` очень просто: посмотрите, что находится слева от точки перед именем функции, — это и есть `this`.

```js
window.myData = 'Important data';

function globalFunction() {
  'use strict';
  console.log(this.myData);
}

window.globalFunction(); // 'Important data'
```

## 3. Явная привязка - Метод функций `.bind()`

Метод `.bind()` не вызывает функцию. Он указывает значение `this`, с которым эта функция будет вызываться.

```js
class SendButton {
  constructor() {
    this.buttonName = 'Send Button';
  }
  click() {
    console.log('I am ' + this.buttonName);
  }
  setEventListeners() {
    // жёстко привязываем контекст при передаче функции
    document.querySelector('.btn').addEventListener('click', this.click.bind(this));
  }
}
const button = new SendButton();
button.setEventListeners();
```

## 4. Автоматическая привязка - вызов с оператором new.

Если вызвать функцию с new, `this` возвращается автоматически. Функция может ничего не возвращать или возвращать примитивное значение, но при её вызове с `new` всё равно вернётся `this`.

Но есть одно исключение. Если функция возвращает объект, вызов функции с `new` вернёт этот объект.

## 5. Привязка во время объявления - стрелочные функции

Их механизм привязки `this` отличается от четырёх рассмотренных способов. Ключевое слово `this` стрелочных функций привязывается не во время вызова, а во время объявления. Из-за этого нет смысла использовать стрелочную функцию как метод объекта.

Если объявить стрелочную функцию внутри функции-конструктора, её значением `this` навсегда станет функция-конструктор.

Если методы находятся в прототипе, не пользуйтесь стрелочными функциями.

## Потеря контекста

Наша задача выводить имя кнопки при каждом нажатии на неё. Но это не сработало, потому что `this` определяется в момент вызова функции, то есть в момент клика по элементу. Важно, что функция `click` не вызывается как метод класса — она передаётся методу `addEventListener` и вызывается из него. Механизм слушателя события такой, что `this` при этом ссылается на DOM-элемент, на котором событие сработало. У DOM-узла нет свойства `buttonName`, поэтому в консоли оказывается сообщение `I am undefined`.

```js
class SendButton {
  constructor() {
    this.buttonName = 'Send Button';
  }

  click() {
    console.log('I am ' + this.buttonName);
  }

  setEventListeners() {
    // Передадим слушателю события метод SendButton.click как колбэк:
    // При клике мы надеемся увидеть сообщение "I am Send Button"
    document.querySelector('.btn').addEventListener('click', this.click);
  }
}

const button = new SendButton();
button.setEventListeners();
```
