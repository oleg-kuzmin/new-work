# [`Типизация функций`](../index.md)

Без присваивания типа для параметров функции им автоматически будет назначен тип any. Поэтому при типизации функции первым делом нужно задать типа для параметров. Результату выполнения функции автоматически неявно присваивается тип в зависимости от параметров, но часто это делается явно.

Функции имеют специальные типы для возвращаемых значений, например `void`, `never`.

## Типы параметров функции

### Обязательные параметры

```ts
function getFullName(firstname: string, surname: string): string {
  return `${firstname} ${surname}`;
}

const getFullNameArrow = (firstname: string, surname: string): string => {
  return `${firstname} ${surname}`;
};

const sum = function (a: number, b: number): number {
  return a + b;
};
```

### Необязательные параметры

```ts
// string | undefined
function log(name: string, userId?: string): void {
  console.log('Hello', name, 'with ID', userId || 'anonym');
}

log('Oleg', '213');
```

### Параметры по умолчанию

```ts
function createPoint(x = 0, y = 0): [number, number] {
  return [x, y];
}
```

### Неизвестное количество параметров

```ts
function average(...nums: number[]) {
  const sum = nums.reduce((current, total) => current + total, 0);
  return sum / nums.length;
}
```

### Сужение типов narrowing

Если мы используем разные типы входных параметров, то мы должны сделать проверку (это называется сужение типов) по каждому из них.

```ts
function printId(id: number | string): void {
  if (typeof id === 'string') {
    console.log(id.toUpperCase());
  } else {
    console.log(id);
  }
}
```

```ts
function welcome(person: [string, string] | string) {
  if (Array.isArray(person)) {
    console.log('Hello', person.join(' '));
  } else {
    console.log('Hello', person);
  }
}
```

```ts
function example(x?: number | string) {
  if (typeof x === 'string') {
    x.toUpperCase();
  } else if (typeof x === 'number') {
    x.toFixed(2);
  } else if (x === undefined) {
    console.log('no value');
  } else {
    console.log('never');
  }
}
```

```ts
function example(strs: string | string[] | null) {
  // сперва проверим что параметр существует,
  // отсекаем все, что будет false
  // или использовать Array.isArray()
  if (strs && typeof strs === 'object') {
    strs.concat([]);
  } else if (typeof strs === 'string') {
    strs.toLowerCase();
  }
}
```

```ts
function example(x: number[] | Date) {
  if (x instanceof Date) {
    x.getMonth();
  } else {
    x.concat([]);
  }
}
```

```ts
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
  if ('swim' in animal) {
    return animal.swim();
  }
  return animal.fly();
}
```

### Объекты в качестве параметров

В отличие от интерфейсов, типизация объектов как параметров функции, не проверяет количество ключей. Их может быть больше. Проверяется только минимальный набор заданных типов ключей.

```ts
function printPoint(point: { x: string; y: string }): void {
  console.log(`Координаты точки это x:${point.x} y:${point.y}`);
}

const obj = {
  x: '1',
  y: '2',
  z: '4',
};

printPoint(obj);
```

### Объекты в качестве параметров с необязательными ключами

Все необязательные кейсы нужны обрабатывать в теле функции.

```ts
function printName(user: { firstName: string; lastName?: string }): void {
  console.log('Hello', user.firstName.toUpperCase());
  if (user.lastName) {
    console.log('Nice to meet you Mr.', user.lastName.toUpperCase());
  }
}

printName({ firstName: 'Oleg' });
printName({ firstName: 'Oleg', lastName: 'Kuzmin' });
```

### Callback в качестве параметра

```ts
// без создания отдельного типа
const function = (callback: () => string): string => {
  return callback();
};

// создание отдельного типа для callback
type Callback = () => string;
const function = (callback: Callback): string => {
  return callback();
};
```

## Тип возвращаемого значения

```ts
function sum(a: number, b: number): number {
  return a + b;
}

function log(name: string): void {
  console.log('Hello', name);
}

function crash(): never {
  throw new Error('crash');
}
```
