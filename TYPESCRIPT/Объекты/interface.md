# [`interface`](../index.md)

- [Описание](#описание)
  - [Отличие interface от type](#отличие-interface-от-type)
- [Пример](#пример)
  - [Обязательные параметры объекта](#обязательные-параметры-объекта)
  - [Методы объекта](#методы-объекта)
  - [Необязательные параметры объекта](#необязательные-параметры-объекта)
  - [Неограниченное количество свойств объекта](#неограниченное-количество-свойств-объекта)
  - [Расширение interface с помощью extends](#расширение-interface-с-помощью-extends)
  - [Расширение interface с помощью одинаковых имен](#расширение-interface-с-помощью-одинаковых-имен)
  - [Получение типа через квадратные скобки](#получение-типа-через-квадратные-скобки)

## [Описание](#interface)

Позволяет вынести типизацию объекта в отдельную сущность. Применяется к объектам и классам.

`interface` объединяются, склеиваются если им заданы одинаковые имена. Причем находясь не только в одном файле.

Для того чтобы предотвратить расширение другим `interface` в другом файле, нужно превратить файл где находится `interface` в модуль. Для этого нужно чтобы в файлы был хотя бы один экспорт любой сущности.

Также возможно не только добавить новые свойства, но и переопределить их.

Для предотвращения пересечения и объединения интерфейсов с какой-либо библиотекой также существует соглашение добавлять букву `I` перед объявлением интерфейса, например `interface IAccount {}`.

Поддерживают стандартный экспорт/импорт модулей.

### [Отличие interface от type](#interface)

- в `interface` нельзя напрямую использовать `union`, только для отдельных свойств
- `interface` используются когда мы хотим расширять интерфейс в будущем
- `interface` используются для классов.
- `type` позволяют создавать примитивы, union, кортежи, разные комбинации
- в `type` нельзя создавать глобальные типы, например `Window` для расширения

## [Пример](#interface)

### [Обязательные параметры объекта](#interface)

```ts
interface User {
  name: string;
  age: string;
  skills: string[];
}

let user: User = {
  name: 'asd',
  age: '18',
  skills: ['1', '2'],
};
```

### [Методы объекта](#interface)

```ts
interface User {
  print(): number;
  print: () => number;
  code: (arg: string) => string;
  log: (id: number) => void;
}
```

### [Необязательные параметры объекта](#interface)

```ts
interface User {
  isNew?: boolean;
  name?: string;
}
```

### [Неограниченное количество свойств объекта](#interface)

```ts
interface User {
  [key: string]: string;
}

// Алтернативный вариант
const user: Record<string, unknown> = {};
```

### [Расширение interface с помощью extends](#interface)

Несколько интерфейсов можно указать через запятую после `extends`.

Также возможно не только добавить новые свойства, но и переопределить их.

```ts
interface User {
  name: string;
  age: string;
  skills: string[];
}

interface UserWithRole extends User {
  roleId: number;
}

let user: UserWithRole = {
  name: 'asd',
  age: '18',
  skills: ['1', '2'],
  roleId: 1,
};
```

### [Расширение interface с помощью одинаковых имен](#interface)

Бывает полезно при использовании внешней библиотеки, чтобы добавить какой-то тип.

```ts
interface User {
  name: string;
}

interface User {
  age: number;
}
```

### [Получение типа через квадратные скобки](#interface)

```ts
type Laptop = {
  brand: string;
};
interface Laptop {
  brand: string;
}

type F = Laptop['brand'];
const F: Laptop['brand'] = true;
```
